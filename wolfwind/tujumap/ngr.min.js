window.NGR_PREFER_CANVAS = !0;
(function(d, g, h) {
    var k = d.L,
        ngr = {};
    "object" === typeof module && "object" === typeof module.exports ? module.exports = ngr : "function" === typeof define && define.amd && define(ngr);
    ngr.noConflict = function() {
        d.L = k;
        return this
    };
    d.L = ngr;
    ngr.Util = {
        extend: function(a) {
            var c = Array.prototype.slice.call(arguments, 1),
                b, f, m, d;
            f = 0;
            for (m = c.length; f < m; f++)
                for (b in d = c[f] || {}, d) d.hasOwnProperty(b) && (a[b] = d[b]);
            return a
        },
        bind: function(a, c) {
            var b = 2 < arguments.length ? Array.prototype.slice.call(arguments, 2) : null;
            return function() {
                return a.apply(c,
                    b || arguments)
            }
        },
        stamp: function() {
            var a = 0;
            return function(c) {
                c._ngr_id = c._ngr_id || ++a;
                return c._ngr_id
            }
        }(),
        invokeEach: function(a, c, b) {
            var f, m;
            if ("object" === typeof a) {
                m = Array.prototype.slice.call(arguments, 3);
                for (f in a) c.apply(b, [f, a[f]].concat(m));
                return !0
            }
            return !1
        },
        limitExecByInterval: function(a, c, b) {
            var f, m;
            return function v() {
                var d = arguments;
                f ? m = !0 : (f = !0, setTimeout(function() {
                    f = !1;
                    m && (v.apply(b, d), m = !1)
                }, c), a.apply(b, d))
            }
        },
        falseFn: function() {
            return !1
        },
        formatNum: function(a, c) {
            var b = Math.pow(10,
                c || 5);
            return Math.round(a * b) / b
        },
        trim: function(a) {
            return a.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "")
        },
        splitWords: function(a) {
            return ngr.Util.trim(a).split(/\s+/)
        },
        setOptions: function(a, c) {
            a.options = ngr.extend({}, a.options, c);
            return a.options
        },
        getParamString: function(a, c, b) {
            var f = [],
                m;
            for (m in a) f.push(encodeURIComponent(b ? m.toUpperCase() : m) + "=" + encodeURIComponent(a[m]));
            return (c && -1 !== c.indexOf("?") ? "&" : "?") + f.join("&")
        },
        template: function(a, c) {
            return a.replace(/\{ *([\w_]+) *\}/g, function(a, b) {
                var m = c[b];
                if (m === h) throw Error("No value provided for variable " + a);
                "function" === typeof m && (m = m(c));
                return m
            })
        },
        isArray: Array.isArray || function(a) {
            return "[object Array]" === Object.prototype.toString.call(a)
        },
        emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    };
    (function() {
        function a(a) {
            var c, b, e = ["webkit", "moz", "o", "ms"];
            for (c = 0; c < e.length && !b; c++) b = d[e[c] + a];
            return b
        }

        function c(a) {
            var c = +new Date,
                b = Math.max(0, 16 - (c - e));
            e = c + b;
            return d.setTimeout(a, b)
        }
        var e = 0,
            f = d.requestAnimationFrame ||
                a("RequestAnimationFrame") || c,
            m = d.cancelAnimationFrame || a("CancelAnimationFrame") || a("CancelRequestAnimationFrame") || function(a) {
                    d.clearTimeout(a)
                };
        ngr.Util.requestAnimFrame = function(a, e, m, g) {
            a = ngr.bind(a, e);
            if (m && f === c) a();
            else return f.call(d, a, g)
        };
        ngr.Util.cancelAnimFrame = function(a) {
            a && m.call(d, a)
        }
    })();
    ngr.extend = ngr.Util.extend;
    ngr.bind = ngr.Util.bind;
    ngr.stamp = ngr.Util.stamp;
    ngr.setOptions = ngr.Util.setOptions;
    ngr.Class = function() {};
    ngr.Class.extend = function(a) {
        var c = function() {
                this.initialize && this.initialize.apply(this,
                    arguments);
                this._initHooks && this.callInitHooks()
            },
            e = function() {};
        e.prototype = this.prototype;
        var f = new e;
        f.constructor = c;
        c.prototype = f;
        for (var m in this) this.hasOwnProperty(m) && "prototype" !== m && (c[m] = this[m]);
        a.statics && (ngr.extend(c, a.statics), delete a.statics);
        a.includes && (ngr.Util.extend.apply(null, [f].concat(a.includes)), delete a.includes);
        a.options && f.options && (a.options = ngr.extend({}, f.options, a.options));
        ngr.extend(f, a);
        f._initHooks = [];
        var d = this;
        c.__super__ = d.prototype;
        f.callInitHooks = function() {
            if (!this._initHooksCalled) {
                d.prototype.callInitHooks &&
                d.prototype.callInitHooks.call(this);
                this._initHooksCalled = !0;
                for (var a = 0, c = f._initHooks.length; a < c; a++) f._initHooks[a].call(this)
            }
        };
        return c
    };
    ngr.Class.include = function(a) {
        ngr.extend(this.prototype, a)
    };
    ngr.Class.mergeOptions = function(a) {
        ngr.extend(this.prototype.options, a)
    };
    ngr.Class.addInitHook = function(a) {
        var c = Array.prototype.slice.call(arguments, 1);
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push("function" === typeof a ? a : function() {
            this[a].apply(this, c)
        })
    };
    ngr.Mixin = {};
    ngr.Mixin.Events = {
        addEventListener: function(a, c, e) {
            if (ngr.Util.invokeEach(a, this.addEventListener, this, c, e)) return this;
            var f = this._ngr_events = this._ngr_events || {},
                m = e && e !== this && ngr.stamp(e),
                d, g, h, n, k;
            a = ngr.Util.splitWords(a);
            d = 0;
            for (g = a.length; d < g; d++) h = {
                action: c,
                context: e || this
            }, n = a[d], m ? (k = n + "_idx", n = k + "_len", k = f[k] = f[k] || {}, k[m] || (k[m] = [], f[n] = (f[n] || 0) + 1), k[m].push(h)) : (f[n] = f[n] || [], f[n].push(h));
            return this
        },
        hasEventListeners: function(a) {
            var c = this._ngr_events;
            return !!c && (a in c && 0 < c[a].length ||
                a + "_idx" in c && 0 < c[a + "_idx_len"])
        },
        removeEventListener: function(a, c, e) {
            if (!this._ngr_events) return this;
            if (!a) return this.clearAllEventListeners();
            if (ngr.Util.invokeEach(a, this.removeEventListener, this, c, e)) return this;
            var f = this._ngr_events,
                m = e && e !== this && ngr.stamp(e),
                d, g, h, k, q, t, y;
            a = ngr.Util.splitWords(a);
            d = 0;
            for (g = a.length; d < g; d++)
                if (h = a[d], k = h + "_idx", q = k + "_len", t = f[k], c) {
                    if (h = m && t ? t[m] : f[h]) {
                        for (k = h.length - 1; 0 <= k; k--) h[k].action !== c || e && h[k].context !== e || (y = h.splice(k, 1), y[0].action = ngr.Util.falseFn);
                        e && t && 0 === h.length && (delete t[m], f[q]--)
                    }
                } else delete f[h], delete f[k], delete f[q];
            return this
        },
        clearAllEventListeners: function() {
            delete this._ngr_events;
            return this
        },
        fireEvent: function(a, c) {
            if (!this.hasEventListeners(a)) return this;
            var e = ngr.Util.extend({}, c, {
                    type: a,
                    target: this
                }),
                f = this._ngr_events,
                m, d, g, h;
            if (f[a])
                for (m = f[a].slice(), d = 0, g = m.length; d < g; d++) m[d].action.call(m[d].context, e);
            f = f[a + "_idx"];
            for (h in f)
                if (m = f[h].slice())
                    for (d = 0, g = m.length; d < g; d++) m[d].action.call(m[d].context, e);
            return this
        },
        addOneTimeEventListener: function(a, c, e) {
            if (ngr.Util.invokeEach(a, this.addOneTimeEventListener, this, c, e)) return this;
            var f = ngr.bind(function() {
                this.removeEventListener(a, c, e).removeEventListener(a, f, e)
            }, this);
            return this.addEventListener(a, c, e).addEventListener(a, f, e)
        }
    };
    ngr.Mixin.Events.on = ngr.Mixin.Events.addEventListener;
    ngr.Mixin.Events.off = ngr.Mixin.Events.removeEventListener;
    ngr.Mixin.Events.once = ngr.Mixin.Events.addOneTimeEventListener;
    ngr.Mixin.Events.fire = ngr.Mixin.Events.fireEvent;
    (function() {
        var a = "ActiveXObject" in
                d,
            c = a && !g.addEventListener,
            e = navigator.userAgent.toLowerCase(),
            f = -1 !== e.indexOf("webkit"),
            m = -1 !== e.indexOf("chrome"),
            p = -1 !== e.indexOf("phantom"),
            v = -1 !== e.indexOf("android"),
            r = -1 !== e.search("android [23]"),
            e = -1 !== e.indexOf("gecko"),
            k = typeof orientation !== h + "",
            q = d.navigator && d.navigator.msPointerEnabled && d.navigator.msMaxTouchPoints && !d.PointerEvent,
            t = d.PointerEvent && d.navigator.pointerEnabled && d.navigator.maxTouchPoints || q,
            y = "devicePixelRatio" in d && 1 < d.devicePixelRatio || "matchMedia" in d && d.matchMedia("(min-resolution:144dppi)") &&
                d.matchMedia("(min-resolution:144dppi)").matches,
            l = g.documentElement,
            A = a && "transition" in l.style,
            x = "WebKitCSSMatrix" in d && "m11" in new d.WebKitCSSMatrix && !r,
            B = "MozPerspective" in l.style,
            z = "OTransition" in l.style,
            G = !d.L_DISABLE_3D && (A || x || B || z) && !p,
            p = !d.L_NO_TOUCH && !p && function() {
                    if (t || "ontouchstart" in l) return !0;
                    var a = g.createElement("div"),
                        c = !1;
                    if (!a.setAttribute) return !1;
                    a.setAttribute("ontouchstart", "return;");
                    "function" === typeof a.ontouchstart && (c = !0);
                    a.removeAttribute("ontouchstart");
                    return c
                }();
        ngr.Browser = {
            ie: a,
            ielt9: c,
            webkit: f,
            gecko: e && !f && !d.opera && !a,
            android: v,
            android23: r,
            chrome: m,
            ie3d: A,
            webkit3d: x,
            gecko3d: B,
            opera3d: z,
            any3d: G,
            mobile: k,
            mobileWebkit: k && f,
            mobileWebkit3d: k && x,
            mobileOpera: k && d.opera,
            touch: p,
            msPointer: q,
            pointer: t,
            retina: y
        }
    })();
    ngr.Algorithm = {
        pointDistance: function(a, c, b) {
            if ("x" in a && "x" in c && "y" in a && "y" in c) return Math.sqrt(Math.pow(a.x - c.x, 2) + Math.pow(a.y - c.y, 2));
            var f, m = 0;
            if ((f = a.length) !== c.length) return NaN;
            for (var d = 0; d < f; ++d) m += Math.pow(a[d] - c[d], 2);
            return b ? m : Math.sqrt(m)
        },
        pointSegmentDistance: function(a, c, e) {
            var f;
            f = ngr.Algorithm.pointDistance(c, e);
            if (1E-5 >= f) return 0;
            e = ngr.Algorithm.pointDistance(a, e);
            if (1E-5 >= e) return 0;
            a = ngr.Algorithm.pointDistance(a, c);
            if (1E-5 >= a || f * f >= e * e + a * a) return e;
            if (e * e >= f * f + a * a) return f;
            c = (a + e + f) / 2;
            return 2 * Math.sqrt(Math.abs(c * (c - a) * (c - e) * (c - f))) / a
        },
        dotProduct: function(a, c) {
            if ("x" in a && "x" in c && "y" in a && "y" in c) return a.x * c.x + a.y * c.y;
            var b, f = 0;
            if ((b = a.length) !== c.length) return NaN;
            for (var m = 0; m < b; ++m) f += a[m] * c[m];
            return f
        },
        pointInTriangle: function(a,
                                  c, e, f) {
            e = [(e.x || e[0]) - (a.x || a[0]), (e.y || e[1]) - (a.y || a[1])];
            c = [(c.x || c[0]) - (a.x || a[0]), (c.y || c[1]) - (a.y || a[1])];
            var m = [(f.x || f[0]) - (a.x || a[0]), (f.y || f[1]) - (a.y || a[1])];
            a = ngr.Algorithm.dotProduct(e, e);
            f = ngr.Algorithm.dotProduct(e, c);
            e = ngr.Algorithm.dotProduct(e, m);
            var d = ngr.Algorithm.dotProduct(c, c);
            c = ngr.Algorithm.dotProduct(c, m);
            m = 1 / (a * d - f * f);
            d = (d * e - f * c) * m;
            if (0 > d || 1 < d) return !1;
            a = (a * c - f * e) * m;
            return 0 > a || 1 < a ? !1 : 1 >= d + a
        }
    };
    ngr.Point = function(a, c, b) {
        this.x = b ? Math.round(a) : a;
        this.y = b ? Math.round(c) : c
    };
    ngr.Point.prototype = {
        clone: function() {
            return new ngr.Point(this.x, this.y)
        },
        add: function(a) {
            return this.clone()._add(ngr.point(a))
        },
        _add: function(a) {
            this.x += a.x;
            this.y += a.y;
            return this
        },
        subtract: function(a) {
            return this.clone()._subtract(ngr.point(a))
        },
        _subtract: function(a) {
            this.x -= a.x;
            this.y -= a.y;
            return this
        },
        divideBy: function(a) {
            return this.clone()._divideBy(a)
        },
        _divideBy: function(a) {
            this.x /= a;
            this.y /= a;
            return this
        },
        multiplyBy: function(a) {
            return this.clone()._multiplyBy(a)
        },
        _multiplyBy: function(a) {
            this.x *= a;
            this.y *= a;
            return this
        },
        round: function() {
            return this.clone()._round()
        },
        _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this
        },
        floor: function() {
            return this.clone()._floor()
        },
        _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this
        },
        distanceTo: function(a) {
            a = ngr.point(a);
            var c = a.x - this.x;
            a = a.y - this.y;
            return Math.sqrt(c * c + a * a)
        },
        equals: function(a) {
            a = ngr.point(a);
            return a.x === this.x && a.y === this.y
        },
        contains: function(a) {
            a = ngr.point(a);
            return Math.abs(a.x) <= Math.abs(this.x) && Math.abs(a.y) <=
                Math.abs(this.y)
        },
        toString: function() {
            return "Point(" + ngr.Util.formatNum(this.x) + ", " + ngr.Util.formatNum(this.y) + ")"
        }
    };
    ngr.point = function(a, c, e) {
        return a instanceof ngr.Point ? a : ngr.Util.isArray(a) ? new ngr.Point(a[0], a[1]) : a === h || null === a ? a : new ngr.Point(a, c, e)
    };
    ngr.Bounds = function(a, c) {
        if (a)
            for (var b = c ? [a, c] : a, f = 0, m = b.length; f < m; f++) this.extend(b[f])
    };
    ngr.Bounds.prototype = {
        extend: function(a) {
            a = ngr.point(a);
            this.min || this.max ? (this.min.x = Math.min(a.x, this.min.x), this.max.x = Math.max(a.x, this.max.x), this.min.y = Math.min(a.y,
                this.min.y), this.max.y = Math.max(a.y, this.max.y)) : (this.min = a.clone(), this.max = a.clone());
            return this
        },
        getCenter: function(a) {
            return new ngr.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, a)
        },
        getBottomLeft: function() {
            return new ngr.Point(this.min.x, this.max.y)
        },
        getTopRight: function() {
            return new ngr.Point(this.max.x, this.min.y)
        },
        getSize: function() {
            return this.max.subtract(this.min)
        },
        contains: function(a) {
            var c;
            a = "number" === typeof a[0] || a instanceof ngr.Point ? ngr.point(a) : ngr.bounds(a);
            a instanceof ngr.Bounds ?
                (c = a.min, a = a.max) : c = a;
            return c.x >= this.min.x && a.x <= this.max.x && c.y >= this.min.y && a.y <= this.max.y
        },
        intersects: function(a) {
            a = ngr.bounds(a);
            var c = this.min,
                e = this.max,
                f = a.min;
            a = a.max;
            var m = a.y >= c.y && f.y <= e.y;
            return a.x >= c.x && f.x <= e.x && m
        },
        isValid: function() {
            return !(!this.min || !this.max)
        }
    };
    ngr.bounds = function(a, c) {
        return !a || a instanceof ngr.Bounds ? a : new ngr.Bounds(a, c)
    };
    ngr.Transformation = function(a, c, b, f) {
        this._a = a;
        this._b = c;
        this._c = b;
        this._d = f
    };
    ngr.Transformation.prototype = {
        transform: function(a, c) {
            return this._transform(a.clone(),
                c)
        },
        _transform: function(a, c) {
            c = c || 1;
            a.x = c * (this._a * a.x + this._b);
            a.y = c * (this._c * a.y + this._d);
            return a
        },
        untransform: function(a, c) {
            c = c || 1;
            return new ngr.Point((a.x / c - this._b) / this._a, (a.y / c - this._d) / this._c)
        }
    };
    ngr.DomUtil = {
        get: function(a) {
            return "string" === typeof a ? g.getElementById(a) : a
        },
        getStyle: function(a, c) {
            var b = a.style[c];
            !b && a.currentStyle && (b = a.currentStyle[c]);
            b && "auto" !== b || !g.defaultView || (b = (b = g.defaultView.getComputedStyle(a, null)) ? b[c] : null);
            return "auto" === b ? null : b
        },
        getViewportOffset: function(a) {
            var c =
                    0,
                e = 0,
                f = a,
                m = g.body,
                d = g.documentElement,
                h;
            do {
                c += f.offsetTop || 0;
                e += f.offsetLeft || 0;
                c += parseInt(ngr.DomUtil.getStyle(f, "borderTopWidth"), 10) || 0;
                e += parseInt(ngr.DomUtil.getStyle(f, "borderLeftWidth"), 10) || 0;
                h = ngr.DomUtil.getStyle(f, "position");
                if (f.offsetParent === m && "absolute" === h) break;
                if ("fixed" === h) {
                    c += m.scrollTop || d.scrollTop || 0;
                    e += m.scrollLeft || d.scrollLeft || 0;
                    break
                }
                if ("relative" === h && !f.offsetLeft) {
                    h = ngr.DomUtil.getStyle(f, "width");
                    var r = ngr.DomUtil.getStyle(f, "max-width"),
                        k = f.getBoundingClientRect();
                    if ("none" !==
                        h || "none" !== r) e += k.left + f.clientLeft;
                    c += k.top + (m.scrollTop || d.scrollTop || 0);
                    break
                }
                f = f.offsetParent
            } while (f);
            f = a;
            do {
                if (f === m) break;
                c -= f.scrollTop || 0;
                e -= f.scrollLeft || 0;
                f = f.parentNode
            } while (f);
            return new ngr.Point(e, c)
        },
        documentIsLtr: function() {
            ngr.DomUtil._docIsLtrCached || (ngr.DomUtil._docIsLtrCached = !0, ngr.DomUtil._docIsLtr = "ltr" === ngr.DomUtil.getStyle(g.body, "direction"));
            return ngr.DomUtil._docIsLtr
        },
        create: function(a, c, b) {
            a = g.createElement(a);
            a.className = c;
            b && b.appendChild(a);
            return a
        },
        hasClass: function(a,
                           c) {
            if (a.classList !== h) return a.classList.contains(c);
            var e = ngr.DomUtil._getClass(a);
            return 0 < e.length && (new RegExp("(^|\\s)" + c + "(\\s|$)")).test(e)
        },
        addClass: function(a, c) {
            if (a.classList !== h)
                for (var e = ngr.Util.splitWords(c), f = 0, d = e.length; f < d; f++) a.classList.add(e[f]);
            else ngr.DomUtil.hasClass(a, c) || (e = ngr.DomUtil._getClass(a), ngr.DomUtil._setClass(a, (e ? e + " " : "") + c))
        },
        removeClass: function(a, c) {
            a.classList !== h ? a.classList.remove(c) : ngr.DomUtil._setClass(a, ngr.Util.trim((" " + ngr.DomUtil._getClass(a) + " ").replace(" " +
            c + " ", " ")))
        },
        _setClass: function(a, c) {
            a.className.baseVal === h ? a.className = c : a.className.baseVal = c
        },
        _getClass: function(a) {
            return a.className.baseVal === h ? a.className : a.className.baseVal
        },
        setOpacity: function(a, c) {
            if ("opacity" in a.style) a.style.opacity = c;
            else if ("filter" in a.style) {
                var b = !1;
                try {
                    b = a.filters.item("DXImageTransform.Microsoft.Alpha")
                } catch (f) {
                    if (1 === c) return
                }
                c = Math.round(100 * c);
                b ? (b.Enabled = 100 !== c, b.Opacity = c) : a.style.filter += " progid:DXImageTransform.Microsoft.Alpha(opacity=" + c + ")"
            }
        },
        testProp: function(a) {
            for (var c =
                g.documentElement.style, b = 0; b < a.length; b++)
                if (a[b] in c) return a[b];
            return !1
        },
        getTranslateString: function(a) {
            var c = ngr.Browser.webkit3d;
            return "translate" + (c ? "3d" : "") + "(" + a.x + "px," + a.y + "px" + ((c ? ",0" : "") + ")")
        },
        getScaleString: function(a, c) {
            return ngr.DomUtil.getTranslateString(c.add(c.multiplyBy(-1 * a))) + (" scale(" + a + ") ")
        },
        setPosition: function(a, c, e) {
            a._ngr_pos = c;
            !e && ngr.Browser.any3d ? a.style[ngr.DomUtil.TRANSFORM] = ngr.DomUtil.getTranslateString(c) : (a.style.left = c.x + "px", a.style.top = c.y + "px")
        },
        getPosition: function(a) {
            return a._ngr_pos
        }
    };
    ngr.DomUtil.TRANSFORM = ngr.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]);
    ngr.DomUtil.TRANSITION = ngr.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
    ngr.DomUtil.TRANSITION_END = "webkitTransition" === ngr.DomUtil.TRANSITION || "OTransition" === ngr.DomUtil.TRANSITION ? ngr.DomUtil.TRANSITION + "End" : "transitionend";
    (function() {
        if ("onselectstart" in g) ngr.extend(ngr.DomUtil, {
            disableTextSelection: function() {
                ngr.DomEvent.on(d, "selectstart", ngr.DomEvent.preventDefault)
            },
            enableTextSelection: function() {
                ngr.DomEvent.off(d, "selectstart", ngr.DomEvent.preventDefault)
            }
        });
        else {
            var a = ngr.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
            ngr.extend(ngr.DomUtil, {
                disableTextSelection: function() {
                    if (a) {
                        var c = g.documentElement.style;
                        this._userSelect = c[a];
                        c[a] = "none"
                    }
                },
                enableTextSelection: function() {
                    a && (g.documentElement.style[a] = this._userSelect, delete this._userSelect)
                }
            })
        }
        ngr.extend(ngr.DomUtil, {
            disableImageDrag: function() {
                ngr.DomEvent.on(d, "dragstart",
                    ngr.DomEvent.preventDefault)
            },
            enableImageDrag: function() {
                ngr.DomEvent.off(d, "dragstart", ngr.DomEvent.preventDefault)
            }
        })
    })();

    ///---------------------------------- LatLng ---------------------------------------
    ngr.LatLng = function(a, c, b) {
        a = parseFloat(a);
        c = parseFloat(c);
        if (isNaN(a) || isNaN(c)) throw Error("Invalid LatLng object: (" + a + ", " + c + ")");
        this.lat = a;
        this.lng = c;
        b !== h && (this.alt = parseFloat(b))
    };
    ngr.extend(ngr.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1E-9
    });
    ngr.LatLng.prototype = {
        equals: function(a) {
            if (!a) return !1;
            a = ngr.latLng(a);
            return Math.max(Math.abs(this.lat - a.lat), Math.abs(this.lng -
                a.lng)) <= ngr.LatLng.MAX_MARGIN
        },
        toString: function(a) {
            return "LatLng(" + ngr.Util.formatNum(this.lat, a) + ", " + ngr.Util.formatNum(this.lng, a) + ")"
        },
        distanceTo: function(a) {
            a = ngr.latLng(a);
            var c = ngr.LatLng.DEG_TO_RAD,
                e = (a.lng - this.lng) * c,
                f = this.lat * c,
                d = a.lat * c;
            a = Math.sin((a.lat - this.lat) * c / 2);
            e = Math.sin(e / 2);
            f = a * a + e * e * Math.cos(f) * Math.cos(d);
            return 12756274 * Math.atan2(Math.sqrt(f), Math.sqrt(1 - f))
        },
        wrap: function(a, c) {
            var e = this.lng;
            a = a || -180;
            c = c || 180;
            return new ngr.LatLng(this.lat, (e + c) % (c - a) + (e < a || e === c ? c : a))
        }
    };
    ngr.latLng =
        function(a, c) {
            return a instanceof ngr.LatLng ? a : ngr.Util.isArray(a) ? "number" === typeof a[0] || "string" === typeof a[0] ? new ngr.LatLng(a[0], a[1], a[2]) : null : a === h || null === a ? a : "object" === typeof a && "lat" in a ? new ngr.LatLng(a.lat, "lng" in a ? a.lng : a.lon) : c === h ? null : new ngr.LatLng(a, c)
        };
    ngr.LatLngBounds = function(a, c) {
        if (a)
            for (var b = c ? [a, c] : a, f = 0, d = b.length; f < d; f++) this.extend(b[f])
    };
    ngr.LatLngBounds.prototype = {
        extend: function(a) {
            if (!a) return this;
            var c = ngr.latLng(a);
            a = null !== c ? c : ngr.latLngBounds(a);
            a instanceof ngr.LatLng ? this._southWest ||
            this._northEast ? (this._southWest.lat = Math.min(a.lat, this._southWest.lat), this._southWest.lng = Math.min(a.lng, this._southWest.lng), this._northEast.lat = Math.max(a.lat, this._northEast.lat), this._northEast.lng = Math.max(a.lng, this._northEast.lng)) : (this._southWest = new ngr.LatLng(a.lat, a.lng), this._northEast = new ngr.LatLng(a.lat, a.lng)) : a instanceof ngr.LatLngBounds && (this.extend(a._southWest), this.extend(a._northEast));
            return this
        },
        pad: function(a) {
            var c = this._southWest,
                e = this._northEast,
                f = Math.abs(c.lat - e.lat) *
                    a;
            a *= Math.abs(c.lng - e.lng);
            return new ngr.LatLngBounds(new ngr.LatLng(c.lat - f, c.lng - a), new ngr.LatLng(e.lat + f, e.lng + a))
        },
        getCenter: function() {
            return new ngr.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
        },
        getSouthWest: function() {
            return this._southWest
        },
        getNorthEast: function() {
            return this._northEast
        },
        getNorthWest: function() {
            return new ngr.LatLng(this.getNorth(), this.getWest())
        },
        getSouthEast: function() {
            return new ngr.LatLng(this.getSouth(), this.getEast())
        },
        getWest: function() {
            return this._southWest.lng
        },
        getSouth: function() {
            return this._southWest.lat
        },
        getEast: function() {
            return this._northEast.lng
        },
        getNorth: function() {
            return this._northEast.lat
        },
        contains: function(a) {
            a = "number" === typeof a[0] || a instanceof ngr.LatLng ? ngr.latLng(a) : ngr.latLngBounds(a);
            var c = this._southWest,
                e = this._northEast,
                f;
            a instanceof ngr.LatLngBounds ? (f = a.getSouthWest(), a = a.getNorthEast()) : f = a;
            return f.lat >= c.lat && a.lat <= e.lat && f.lng >= c.lng && a.lng <= e.lng
        },
        intersects: function(a) {
            a = ngr.latLngBounds(a);
            var c = this._southWest,
                e = this._northEast,
                f = a.getSouthWest();
            a = a.getNorthEast();
            var d = a.lng >= c.lng && f.lng <= e.lng;
            return a.lat >= c.lat && f.lat <= e.lat && d
        },
        toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join()
        },
        equals: function(a) {
            if (!a) return !1;
            a = ngr.latLngBounds(a);
            return this._southWest.equals(a.getSouthWest()) && this._northEast.equals(a.getNorthEast())
        },
        isValid: function() {
            return !(!this._southWest || !this._northEast)
        }
    };
    ngr.latLngBounds = function(a, c) {
        return !a || a instanceof ngr.LatLngBounds ? a : new ngr.LatLngBounds(a,
            c)
    };
    ngr.Projection = {};
    ngr.Projection.SphericalMercator = {
        MAX_LATITUDE: 85.0511287798,
        project: function(a) {
            var c = ngr.LatLng.DEG_TO_RAD,
                e = this.MAX_LATITUDE,
                e = Math.max(Math.min(e, a.lat), -e);
            a = a.lng * c;
            c = Math.log(Math.tan(Math.PI / 4 + e * c / 2));
            return new ngr.Point(a, c)
        },
        unproject: function(a) {
            var c = ngr.LatLng.RAD_TO_DEG,
                e = a.x * c;
            a = (2 * Math.atan(Math.exp(a.y)) - Math.PI / 2) * c;
            return new ngr.LatLng(a, e)
        }
    };
    ngr.Projection.LonLat = {
        project: function(a) {
            return new ngr.Point(a.lng, a.lat)
        },
        unproject: function(a) {
            return new ngr.LatLng(a.y, a.x)
        }
    };
    ngr.CRS = {
        latLngToPoint: function(a, c) {
            var b = this.projection.project(a),
                f = this.scale(c);
            return this.transformation._transform(b, f)
        },
        pointToLatLng: function(a, c) {
            var b = this.scale(c),
                b = this.transformation.untransform(a, b);
            return this.projection.unproject(b)
        },
        project: function(a) {
            return this.projection.project(a)
        },
        scale: function(a) {
            return 256 * Math.pow(2, a)
        },
        getSize: function(a) {
            a = this.scale(a);
            return ngr.point(a, a)
        }
    };
    ngr.CRS.Simple = ngr.extend({}, ngr.CRS, {
        projection: ngr.Projection.LonLat,
        transformation: new ngr.Transformation(1,
            0, -1, 0),
        scale: function(a) {
            return Math.pow(2, a)
        }
    });
    ngr.CRS.EPSG3857 = ngr.extend({}, ngr.CRS, {
        code: "EPSG:3857",
        projection: ngr.Projection.SphericalMercator,
        transformation: new ngr.Transformation(.5 / Math.PI, .5, -.5 / Math.PI, .5),
        project: function(a) {
            return this.projection.project(a).multiplyBy(6378137)
        },
        unproject: function(a) {
            a = ngr.point(a).divideBy(6378137);
            return this.projection.unproject(a)
        }
    });
    ngr.CRS.EPSG900913 = ngr.extend({}, ngr.CRS.EPSG3857, {
        code: "EPSG:900913"
    });
    ngr.CRS.EPSG4326 = ngr.extend({}, ngr.CRS, {
        code: "EPSG:4326",
        projection: ngr.Projection.LonLat,
        transformation: new ngr.Transformation(1 / 360, .5, -1 / 360, .5)
    });
    ngr.Map = ngr.Class.extend({
        includes: ngr.Mixin.Events,
        options: {
            crs: ngr.CRS.EPSG3857,
            fadeAnimation: ngr.DomUtil.TRANSITION && !ngr.Browser.android23,
            trackResize: !0,
            markerZoomAnimation: ngr.DomUtil.TRANSITION && ngr.Browser.any3d
        },
        initialize: function(a, c) {
            c = ngr.setOptions(this, c);
            this._initContainer(a);
            this._initLayout();
            this._onResize = ngr.bind(this._onResize, this);
            this._initEvents();
            c.maxBounds && this.setMaxBounds(c.maxBounds);
            c.center && c.zoom !== h && this.setView(ngr.latLng(c.center),
                c.zoom, {
                    reset: !0
                });
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._tileLayersNum = 0;
            this.callInitHooks();
            this._addLayers(c.layers)
        },
        setView: function(a, c) {
            c = c === h ? this.getZoom() : c;
            this._resetView(ngr.latLng(a), this._limitZoom(c));
            return this
        },
        setZoom: function(a, c) {
            return this._loaded ? this.setView(this.getCenter(), a, {
                zoom: c
            }) : (this._zoom = this._limitZoom(a), this)
        },
        zoomIn: function(a, c) {
            return this.setZoom(this._zoom + (a || 1), c)
        },
        zoomOut: function(a, c) {
            return this.setZoom(this._zoom - (a || 1),
                c)
        },
        setZoomAround: function(a, c, e) {
            var f = this.getZoomScale(c),
                d = this.getSize().divideBy(2);
            a = (a instanceof ngr.Point ? a : this.latLngToContainerPoint(a)).subtract(d).multiplyBy(1 - 1 / f);
            d = this.containerPointToLatLng(d.add(a));
            return this.setView(d, c, {
                zoom: e
            })
        },
        fitBounds: function(a, c) {
            c = c || {};
            a = a.getBounds ? a.getBounds() : ngr.latLngBounds(a);
            var e = ngr.point(c.paddingTopLeft || c.padding || [0, 0]),
                f = ngr.point(c.paddingBottomRight || c.padding || [0, 0]),
                d = this.getBoundsZoom(a, !1, e.add(f)),
                d = c.maxZoom ? Math.min(c.maxZoom, d) :
                    d,
                e = f.subtract(e).divideBy(2),
                f = this.project(a.getSouthWest(), d),
                g = this.project(a.getNorthEast(), d),
                e = this.unproject(f.add(g).divideBy(2).add(e), d);
            return this.setView(e, d, c)
        },
        fitWorld: function(a) {
            return this.fitBounds([
                [-90, -180],
                [90, 180]
            ], a)
        },
        panTo: function(a, c) {
            return this.setView(a, this._zoom, {
                pan: c
            })
        },
        panBy: function(a) {
            this.fire("movestart");
            this._rawPanBy(ngr.point(a));
            this.fire("move");
            return this.fire("moveend")
        },
        setMaxBounds: function(a) {
            a = ngr.latLngBounds(a);
            this.options.maxBounds = a;
            if (!a) return this.off("moveend",
                this._panInsideMaxBounds, this);
            this._loaded && this._panInsideMaxBounds();
            return this.on("moveend", this._panInsideMaxBounds, this)
        },
        panInsideBounds: function(a, c) {
            var b = this.getCenter(),
                f = this._limitCenter(b, this._zoom, a);
            return b.equals(f) ? this : this.panTo(f, c)
        },
        addLayer: function(a) {
            var c = ngr.stamp(a);
            if (this._layers[c]) return this;
            this._layers[c] = a;
            !a.options || isNaN(a.options.maxZoom) && isNaN(a.options.minZoom) || (this._zoomBoundLayers[c] = a, this._updateZoomLevels());
            this.options.zoomAnimation && ngr.TileLayer &&
            a instanceof ngr.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, a.on("load", this._onTileLayerLoad, this));
            this._loaded && this._layerAdd(a);
            return this
        },
        removeLayer: function(a) {
            var c = ngr.stamp(a);
            if (!this._layers[c]) return this;
            if (this._loaded) a.onRemove(this);
            delete this._layers[c];
            this._loaded && this.fire("layerremove", {
                layer: a
            });
            this._zoomBoundLayers[c] && (delete this._zoomBoundLayers[c], this._updateZoomLevels());
            this.options.zoomAnimation && ngr.TileLayer && a instanceof ngr.TileLayer && (this._tileLayersNum--,
                this._tileLayersToLoad--, a.off("load", this._onTileLayerLoad, this));
            return this
        },
        hasLayer: function(a) {
            return a ? ngr.stamp(a) in this._layers : !1
        },
        eachLayer: function(a, c) {
            for (var b in this._layers) a.call(c, this._layers[b]);
            return this
        },
        invalidateSize: function(a) {
            if (!this._loaded) return this;
            a = ngr.extend({
                animate: !1,
                pan: !0
            }, !0 === a ? {
                animate: !0
            } : a);
            var c = this.getSize();
            this._sizeChanged = !0;
            this._initialCenter = null;
            var e = this.getSize(),
                f = c.divideBy(2).round(),
                d = e.divideBy(2).round(),
                f = f.subtract(d);
            if (!f.x && !f.y) return this;
            a.animate && a.pan ? this.panBy(f) : (a.pan && this._rawPanBy(f), this.fire("move"), a.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(ngr.bind(this.fire, this, "moveend"), 200)) : this.fire("moveend"));
            return this.fire("resize", {
                oldSize: c,
                newSize: e
            })
        },
        addHandler: function(a, c) {
            if (!c) return this;
            var b = this[a] = new c(this);
            this._handlers.push(b);
            this.options[a] && b.enable();
            return this
        },
        remove: function() {
            this._loaded && this.fire("unload");
            this._initEvents("off");
            try {
                delete this._container._ngr
            } catch (a) {
                this._container._ngr =
                    h
            }
            this._clearPanes();
            this._clearControlPos && this._clearControlPos();
            this._clearHandlers();
            return this
        },
        getCenter: function() {
            this._checkIfLoaded();
            return this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
        },
        getZoom: function() {
            return this._zoom
        },
        getBounds: function() {
            var a = this.getPixelBounds(),
                c = this.unproject(a.getBottomLeft()),
                a = this.unproject(a.getTopRight());
            return new ngr.LatLngBounds(c, a)
        },
        getMinZoom: function() {
            return this.options.minZoom ===
            h ? this._layersMinZoom === h ? 0 : this._layersMinZoom : this.options.minZoom
        },
        getMaxZoom: function() {
            return this.options.maxZoom === h ? this._layersMaxZoom === h ? Infinity : this._layersMaxZoom : this.options.maxZoom
        },
        getBoundsZoom: function(a, c, e) {
            a = ngr.latLngBounds(a);
            var f = this.getMinZoom() - (c ? 1 : 0),
                d = this.getMaxZoom(),
                g = this.getSize(),
                h = a.getNorthWest();
            a = a.getSouthEast();
            var r = !0;
            e = ngr.point(e || [0, 0]);
            do f++, r = this.project(a, f).subtract(this.project(h, f)).add(e), r = c ? r.x < g.x || r.y < g.y : g.contains(r); while (r && f <= d);
            return r &&
            c ? null : c ? f : f - 1
        },
        getSize: function() {
            if (!this._size || this._sizeChanged) this._size = new ngr.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1;
            return this._size.clone()
        },
        getPixelBounds: function() {
            var a = this._getTopLeftPoint();
            return new ngr.Bounds(a, a.add(this.getSize()))
        },
        getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._initialTopLeftPoint
        },
        getPanes: function() {
            return this._panes
        },
        getContainer: function() {
            return this._container
        },
        getZoomScale: function(a) {
            var c =
                this.options.crs;
            return c.scale(a) / c.scale(this._zoom)
        },
        getScaleZoom: function(a) {
            return this._zoom + Math.log(a) / Math.LN2
        },
        project: function(a, c) {
            c = c === h ? this._zoom : c;
            return this.options.crs.latLngToPoint(ngr.latLng(a), c)
        },
        unproject: function(a, c) {
            c = c === h ? this._zoom : c;
            return this.options.crs.pointToLatLng(ngr.point(a), c)
        },
        layerPointToLatLng: function(a) {
            a = ngr.point(a).add(this.getPixelOrigin());
            return this.unproject(a)
        },
        latLngToLayerPoint: function(a) {
            return this.project(ngr.latLng(a))._round()._subtract(this.getPixelOrigin())
        },
        containerPointToLayerPoint: function(a) {
            return ngr.point(a).subtract(this._getMapPanePos())
        },
        layerPointToContainerPoint: function(a) {
            return ngr.point(a).add(this._getMapPanePos())
        },
        containerPointToLatLng: function(a) {
            a = this.containerPointToLayerPoint(ngr.point(a));
            return this.layerPointToLatLng(a)
        },
        latLngToContainerPoint: function(a) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(ngr.latLng(a)))
        },
        mouseEventToContainerPoint: function(a) {
            return ngr.DomEvent.getMousePosition(a, this._container)
        },
        mouseEventToLayerPoint: function(a) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(a))
        },
        mouseEventToLatLng: function(a) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(a))
        },
        _initContainer: function(a) {
            a = this._container = ngr.DomUtil.get(a);
            if (!a) throw Error("Map container not found.");
            if (a._ngr) throw Error("Map container is already initialized.");
            a._ngr = !0
        },
        _initLayout: function() {
            var a = this._container;
            ngr.DomUtil.addClass(a, "ngr-container" + (ngr.Browser.touch ? " ngr-touch" : "") + (ngr.Browser.retina ? " ngr-retina" : "") + (ngr.Browser.ielt9 ? " ngr-oldie" : "") + (this.options.fadeAnimation ? " ngr-fade-anim" :
                ""));
            var c = ngr.DomUtil.getStyle(a, "position");
            "absolute" !== c && "relative" !== c && "fixed" !== c && (a.style.position = "relative");
            this._initPanes();
            this._initControlPos && this._initControlPos()
        },
        _initPanes: function() {
            var a = this._panes = {};
            this._mapPane = a.mapPane = this._createPane("ngr-map-pane", this._container);
            this._tilePane = a.tilePane = this._createPane("ngr-tile-pane", this._mapPane);
            a.objectsPane = this._createPane("ngr-objects-pane", this._mapPane);
            a.shadowPane = this._createPane("ngr-shadow-pane");
            a.overlayPane =
                this._createPane("ngr-overlay-pane");
            a.markerPane = this._createPane("ngr-marker-pane");
            a.popupPane = this._createPane("ngr-popup-pane");
            this.options.markerZoomAnimation || (ngr.DomUtil.addClass(a.markerPane, " ngr-zoom-hide"), ngr.DomUtil.addClass(a.shadowPane, " ngr-zoom-hide"), ngr.DomUtil.addClass(a.popupPane, " ngr-zoom-hide"))
        },
        _createPane: function(a, c) {
            return ngr.DomUtil.create("div", a, c || this._panes.objectsPane)
        },
        _clearPanes: function() {
            this._container.removeChild(this._mapPane)
        },
        _addLayers: function(a) {
            a = a ? ngr.Util.isArray(a) ?
                a : [a] : [];
            for (var c = 0, e = a.length; c < e; c++) this.addLayer(a[c])
        },
        _resetView: function(a, c, e, f) {
            var d = this._zoom !== c;
            f || (this.fire("movestart"), d && this.fire("zoomstart"));
            this._zoom = c;
            this._initialCenter = a;
            this._initialTopLeftPoint = this._getNewTopLeftPoint(a);
            e ? this._initialTopLeftPoint._add(this._getMapPanePos()) : ngr.DomUtil.setPosition(this._mapPane, new ngr.Point(0, 0));
            this._tileLayersToLoad = this._tileLayersNum;
            a = !this._loaded;
            this._loaded = !0;
            this.fire("viewreset", {
                hard: !e
            });
            a && (this.fire("load"), this.eachLayer(this._layerAdd,
                this));
            this.fire("move");
            (d || f) && this.fire("zoomend");
            this.fire("moveend", {
                hard: !e
            })
        },
        _rawPanBy: function(a) {
            ngr.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(a))
        },
        _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom()
        },
        _updateZoomLevels: function() {
            var a, c = Infinity,
                b = -Infinity,
                f = this._getZoomSpan();
            for (a in this._zoomBoundLayers) {
                var d = this._zoomBoundLayers[a];
                isNaN(d.options.minZoom) || (c = Math.min(c, d.options.minZoom));
                isNaN(d.options.maxZoom) || (b = Math.max(b, d.options.maxZoom))
            }
            a ===
            h ? this._layersMaxZoom = this._layersMinZoom = h : (this._layersMaxZoom = b, this._layersMinZoom = c);
            f !== this._getZoomSpan() && this.fire("zoomlevelschange")
        },
        _panInsideMaxBounds: function() {
            this.panInsideBounds(this.options.maxBounds)
        },
        _checkIfLoaded: function() {
            if (!this._loaded) throw Error("Set map center and zoom first.");
        },
        _initEvents: function(a) {
            if (ngr.DomEvent) {
                a = a || "on";
                ngr.DomEvent[a](this._container, "click", this._onMouseClick, this);
                var c = "dblclick mousedown mouseup mouseenter mouseleave mousemove contextmenu".split(" "),
                    e, f;
                e = 0;
                for (f = c.length; e < f; e++) ngr.DomEvent[a](this._container, c[e], this._fireMouseEvent, this);
                if (this.options.trackResize) ngr.DomEvent[a](d, "resize", this._onResize, this)
            }
        },
        _onResize: function() {
            ngr.Util.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = ngr.Util.requestAnimFrame(function() {
                this.invalidateSize({
                    debounceMoveend: !0
                })
            }, this, !1, this._container)
        },
        _onMouseClick: function(a) {
            !this._loaded || !a._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || ngr.DomEvent._skipped(a) ||
            (this.fire("preclick"), this._fireMouseEvent(a))
        },
        _fireMouseEvent: function(a) {
            if (this._loaded && !ngr.DomEvent._skipped(a)) {
                var c = a.type,
                    c = "mouseenter" === c ? "mouseover" : "mouseleave" === c ? "mouseout" : c;
                if (this.hasEventListeners(c)) {
                    "contextmenu" === c && ngr.DomEvent.preventDefault(a);
                    var e = this.mouseEventToContainerPoint(a),
                        f = this.containerPointToLayerPoint(e),
                        d = this.layerPointToLatLng(f);
                    this.fire(c, {
                        latlng: d,
                        layerPoint: f,
                        containerPoint: e,
                        originalEvent: a
                    })
                }
            }
        },
        _onTileLayerLoad: function() {
            this._tileLayersToLoad--;
            this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload")
        },
        _clearHandlers: function() {
            for (var a = 0, c = this._handlers.length; a < c; a++) this._handlers[a].disable()
        },
        whenReady: function(a, c) {
            if (this._loaded) a.call(c || this, this);
            else this.on("load", a, c);
            return this
        },
        _layerAdd: function(a) {
            a.onAdd(this);
            this.fire("layeradd", {
                layer: a
            })
        },
        _getMapPanePos: function() {
            return ngr.DomUtil.getPosition(this._mapPane)
        },
        _moved: function() {
            var a = this._getMapPanePos();
            return a && !a.equals([0, 0])
        },
        _getTopLeftPoint: function() {
            return this.getPixelOrigin().subtract(this._getMapPanePos())
        },
        _getNewTopLeftPoint: function(a, c) {
            var b = this.getSize()._divideBy(2);
            return this.project(a, c)._subtract(b)._round()
        },
        _latLngToNewLayerPoint: function(a, c, b) {
            b = this._getNewTopLeftPoint(b, c).add(this._getMapPanePos());
            return this.project(a, c)._subtract(b)
        },
        _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
        },
        _getCenterOffset: function(a) {
            return this.latLngToLayerPoint(a).subtract(this._getCenterLayerPoint())
        },
        _limitCenter: function(a, c, e) {
            if (!e) return a;
            a =
                this.project(a, c);
            var f = this.getSize().divideBy(2),
                f = new ngr.Bounds(a.subtract(f), a.add(f));
            e = this._getBoundsOffset(f, e, c);
            return this.unproject(a.add(e), c)
        },
        _limitOffset: function(a, c) {
            if (!c) return a;
            var e = this.getPixelBounds(),
                e = new ngr.Bounds(e.min.add(a), e.max.add(a));
            return a.add(this._getBoundsOffset(e, c))
        },
        _getBoundsOffset: function(a, c, e) {
            var f = this.project(c.getNorthWest(), e).subtract(a.min);
            c = this.project(c.getSouthEast(), e).subtract(a.max);
            a = this._rebound(f.x, -c.x);
            f = this._rebound(f.y, -c.y);
            return new ngr.Point(a, f)
        },
        _rebound: function(a, c) {
            return 0 < a + c ? Math.round(a - c) / 2 : Math.max(0, Math.ceil(a)) - Math.max(0, Math.floor(c))
        },
        _limitZoom: function(a) {
            var c = this.getMinZoom(),
                b = this.getMaxZoom();
            return Math.max(c, Math.min(b, a))
        }
    });
    ngr.map = function(a, c) {
        return new ngr.Map(a, c)
    };
    ngr.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.314245179,
        R_MAJOR: 6378137,
        project: function(a) {
            var c = ngr.LatLng.DEG_TO_RAD,
                e = this.MAX_LATITUDE,
                f = Math.max(Math.min(e, a.lat), -e),
                e = this.R_MAJOR;
            a = a.lng * c * e;
            var c =
                    f * c,
                f = this.R_MINOR / e,
                f = Math.sqrt(1 - f * f),
                d = f * Math.sin(c),
                d = Math.pow((1 - d) / (1 + d), .5 * f),
                c = Math.tan(.5 * (.5 * Math.PI - c)) / d,
                c = -e * Math.log(c);
            return new ngr.Point(a, c)
        },
        unproject: function(a) {
            var c = ngr.LatLng.RAD_TO_DEG,
                e = this.R_MAJOR,
                f = a.x * c / e,
                d = this.R_MINOR / e,
                d = Math.sqrt(1 - d * d);
            a = Math.exp(-a.y / e);
            for (var e = Math.PI / 2 - 2 * Math.atan(a), g = 15, h = .1; 1E-7 < Math.abs(h) && 0 < --g;) h = d * Math.sin(e), h = Math.PI / 2 - 2 * Math.atan(a * Math.pow((1 - h) / (1 + h), .5 * d)) - e, e += h;
            return new ngr.LatLng(e * c, f)
        }
    };
    ngr.CRS.EPSG3395 = ngr.extend({}, ngr.CRS, {
        code: "EPSG:3395",
        projection: ngr.Projection.Mercator,
        transformation: function() {
            var a = .5 / (Math.PI * ngr.Projection.Mercator.R_MAJOR);
            return new ngr.Transformation(a, .5, -a, .5)
        }()
    });

    ///--------------------------------------Tile Layer-------------------------------------
    ngr.TileLayer = ngr.Class.extend({
        includes: ngr.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: "abc",
            errorTileUrl: "",
            attribution: "",
            zoomOffset: 0,
            opacity: 1,
            unloadInvisibleTiles: ngr.Browser.mobile,
            updateWhenIdle: ngr.Browser.mobile
        },
        initialize: function(a, c) {
            c = ngr.setOptions(this, c);
            c.detectRetina && ngr.Browser.retina && 0 < c.maxZoom && (c.tileSize = Math.floor(c.tileSize /
            2), c.zoomOffset++, 0 < c.minZoom && c.minZoom--, this.options.maxZoom--);
            c.bounds && (c.bounds = ngr.latLngBounds(c.bounds));
            this._url = a;
            var e = this.options.subdomains;
            "string" === typeof e && (this.options.subdomains = e.split(""))
        },
        onAdd: function(a) {
            this._map = a;
            this._animated = a._zoomAnimated;
            this._initContainer();
            a.on({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            if (this._animated) a.on({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this);
            this.options.updateWhenIdle || (this._limitedUpdate = ngr.Util.limitExecByInterval(this._update,
                150, this), a.on("move", this._limitedUpdate, this));
            this._reset();
            this._update()
        },
        addTo: function(a) {
            a.addLayer(this);
            return this
        },
        onRemove: function(a) {
            this._container.parentNode.removeChild(this._container);
            a.off({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            this._animated && a.off({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this);
            this.options.updateWhenIdle || a.off("move", this._limitedUpdate, this);
            this._map = this._container = null
        },
        bringToFront: function() {
            var a = this._map._panes.tilePane;
            this._container &&
            (a.appendChild(this._container), this._setAutoZIndex(a, Math.max));
            return this
        },
        bringToBack: function() {
            var a = this._map._panes.tilePane;
            this._container && (a.insertBefore(this._container, a.firstChild), this._setAutoZIndex(a, Math.min));
            return this
        },
        getAttribution: function() {
            return this.options.attribution
        },
        getContainer: function() {
            return this._container
        },
        setOpacity: function(a) {
            this.options.opacity = a;
            this._map && this._updateOpacity();
            return this
        },
        setZIndex: function(a) {
            this.options.zIndex = a;
            this._updateZIndex();
            return this
        },
        setUrl: function(a, c) {
            this._url = a;
            c || this.redraw();
            return this
        },
        redraw: function() {
            this._map && (this._reset({
                hard: !0
            }), this._update());
            return this
        },
        _updateZIndex: function() {
            this._container && this.options.zIndex !== h && (this._container.style.zIndex = this.options.zIndex)
        },
        _setAutoZIndex: function(a, c) {
            var b = a.children,
                f = -c(Infinity, -Infinity),
                d, g, h;
            g = 0;
            for (h = b.length; g < h; g++) b[g] !== this._container && (d = parseInt(b[g].style.zIndex, 10), isNaN(d) || (f = c(f, d)));
            this.options.zIndex = this._container.style.zIndex =
                (isFinite(f) ? f : 0) + c(1, -1)
        },
        _updateOpacity: function() {
            var a, c = this._tiles;
            if (ngr.Browser.ielt9)
                for (a in c) ngr.DomUtil.setOpacity(c[a], this.options.opacity);
            else ngr.DomUtil.setOpacity(this._container, this.options.opacity)
        },
        _initContainer: function() {
            var a = this._map._panes.tilePane;
            this._container || (this._container = ngr.DomUtil.create("div", "ngr-layer"), this._updateZIndex(), this._animated ? (this._bgBuffer = ngr.DomUtil.create("div", "ngr-tile-container", this._container), this._tileContainer = ngr.DomUtil.create("div", "ngr-tile-container",
                this._container)) : this._tileContainer = this._container, a.appendChild(this._container), 1 > this.options.opacity && this._updateOpacity())
        },
        _reset: function(a) {
            for (var c in this._tiles) this.fire("tileunload", {
                tile: this._tiles[c]
            });
            this._tiles = {};
            this._tilesToLoad = 0;
            this.options.reuseTiles && (this._unusedTiles = []);
            this._tileContainer.innerHTML = "";
            this._animated && a && a.hard && this._clearBgBuffer();
            this._initContainer()
        },
        _getTileSize: function() {
            var a = this._map,
                c = a.getZoom() + this.options.zoomOffset,
                b = this.options.maxNativeZoom,
                f = this.options.tileSize;
            b && c > b && (f = Math.round(a.getZoomScale(c) / a.getZoomScale(b) * f));
            return f
        },
        _update: function() {
            if (this._map) {
                var a = this._map,
                    c = a.getPixelBounds(),
                    a = a.getZoom(),
                    e = this._getTileSize();
                a > this.options.maxZoom || a < this.options.minZoom || (c = ngr.bounds(c.min.divideBy(e)._floor(), c.max.divideBy(e)._floor()), this._addTilesFromCenterOut(c), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(c))
            }
        },
        _addTilesFromCenterOut: function(a) {
            var c = [],
                e = a.getCenter(),
                f,
                d, h;
            for (f = a.min.y; f <= a.max.y; f++)
                for (d = a.min.x; d <= a.max.x; d++) h = new ngr.Point(d, f), this._tileShouldBeLoaded(h) && c.push(h);
            a = c.length;
            if (0 !== a) {
                c.sort(function(a, c) {
                    return a.distanceTo(e) - c.distanceTo(e)
                });
                f = g.createDocumentFragment();
                this._tilesToLoad || this.fire("loading");
                this._tilesToLoad += a;
                for (d = 0; d < a; d++) this._addTile(c[d], f);
                this._tileContainer.appendChild(f)
            }
        },
        _tileShouldBeLoaded: function(a) {
            if (a.x + ":" + a.y in this._tiles) return !1;
            var c = this.options;
            if (!c.continuousWorld) {
                var b = this._getWrapTileNum();
                if (c.noWrap && (0 > a.x || a.x >= b.x) || 0 > a.y || a.y >= b.y) return !1
            }
            return c.bounds && (b = c.tileSize, a = a.multiplyBy(b), b = a.add([b, b]), a = this._map.unproject(a), b = this._map.unproject(b), c.continuousWorld || c.noWrap || (a = a.wrap(), b = b.wrap()), !c.bounds.intersects([a, b])) ? !1 : !0
        },
        _removeOtherTiles: function(a) {
            var c, b, f;
            for (f in this._tiles) c = f.split(":"), b = parseInt(c[0], 10), c = parseInt(c[1], 10), (b < a.min.x || b > a.max.x || c < a.min.y || c > a.max.y) && this._removeTile(f)
        },
        _removeTile: function(a) {
            var c = this._tiles[a];
            this.fire("tileunload", {
                tile: c,
                url: c.src
            });
            this.options.reuseTiles ? (ngr.DomUtil.removeClass(c, "ngr-tile-loaded"), this._unusedTiles.push(c)) : c.parentNode === this._tileContainer && this._tileContainer.removeChild(c);
            ngr.Browser.android || (c.onload = null, c.src = ngr.Util.emptyImageUrl);
            delete this._tiles[a]
        },
        _addTile: function(a, c) {
            var e = this._getTilePos(a),
                f = this._getTile();
            ngr.DomUtil.setPosition(f, e, ngr.Browser.chrome);
            this._tiles[a.x + ":" + a.y] = f;
            this._loadTile(f, a);
            f.parentNode !== this._tileContainer && c.appendChild(f)
        },
        _getZoomForUrl: function() {
            var a =
                    this.options,
                c = this._map.getZoom();
            a.zoomReverse && (c = a.maxZoom - c);
            c += a.zoomOffset;
            return a.maxNativeZoom ? Math.min(c, a.maxNativeZoom) : c
        },
        _getTilePos: function(a) {
            var c = this._map.getPixelOrigin(),
                b = this._getTileSize();
            return a.multiplyBy(b).subtract(c)
        },
        getTileUrl: function(a) {
            return ngr.Util.template(this._url, ngr.extend({
                s: this._getSubdomain(a),
                z: a.z,
                x: a.x,
                y: a.y
            }, this.options))
        },
        _getWrapTileNum: function() {
            return this._map.options.crs.getSize(this._map.getZoom()).divideBy(this._getTileSize())._floor()
        },
        _adjustTilePoint: function(a) {
            var c = this._getWrapTileNum();
            this.options.continuousWorld || this.options.noWrap || (a.x = (a.x % c.x + c.x) % c.x);
            this.options.tms && (a.y = c.y - a.y - 1);
            a.z = this._getZoomForUrl()
        },
        _getSubdomain: function(a) {
            a = Math.abs(a.x + a.y) % this.options.subdomains.length;
            return this.options.subdomains[a]
        },
        _getTile: function() {
            if (this.options.reuseTiles && 0 < this._unusedTiles.length) {
                var a = this._unusedTiles.pop();
                this._resetTile(a);
                return a
            }
            return this._createTile()
        },
        _resetTile: function() {},
        _createTile: function() {
            var a =
                ngr.DomUtil.create("img", "ngr-tile");
            a.style.width = a.style.height = this._getTileSize() + "px";
            a.galleryimg = "no";
            a.onselectstart = a.onmousemove = ngr.Util.falseFn;
            ngr.Browser.ielt9 && this.options.opacity !== h && ngr.DomUtil.setOpacity(a, this.options.opacity);
            ngr.Browser.mobileWebkit3d && (a.style.WebkitBackfaceVisibility = "hidden");
            return a
        },
        _loadTile: function(a, c) {
            a._layer = this;
            a.onload = this._tileOnLoad;
            a.onerror = this._tileOnError;
            this._adjustTilePoint(c);
            a.src = this.getTileUrl(c);
            this.fire("tileloadstart", {
                tile: a,
                url: a.src
            })
        },
        _tileLoaded: function() {
            this._tilesToLoad--;
            this._animated && ngr.DomUtil.addClass(this._tileContainer, "ngr-zoom-animated");
            this._tilesToLoad || (this.fire("load"), this._animated && (clearTimeout(this._clearBgBufferTimer), this._clearBgBufferTimer = setTimeout(ngr.bind(this._clearBgBuffer, this), 500)))
        },
        _tileOnLoad: function() {
            var a = this._layer;
            this.src !== ngr.Util.emptyImageUrl && (ngr.DomUtil.addClass(this, "ngr-tile-loaded"), a.fire("tileload", {
                tile: this,
                url: this.src
            }));
            a._tileLoaded()
        },
        _tileOnError: function() {
            var a = this._layer;
            a.fire("tileerror", {
                tile: this,
                url: this.src
            });
            var c = a.options.errorTileUrl;
            c && (this.src = c);
            a._tileLoaded()
        }
    });
    ngr.tileLayer = function(a, c) {
        return new ngr.TileLayer(a, c)
    };
    ngr.TileLayer.WMS = ngr.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: !1
        },
        initialize: function(a, c) {
            this._url = a;
            var e = ngr.extend({}, this.defaultWmsParams),
                f = c.tileSize || this.options.tileSize;
            e.width = c.detectRetina && ngr.Browser.retina ? e.height = 2 * f : e.height = f;
            for (var d in c) this.options.hasOwnProperty(d) ||
            "crs" === d || (e[d] = c[d]);
            this.wmsParams = e;
            ngr.setOptions(this, c)
        },
        onAdd: function(a) {
            this._crs = this.options.crs || a.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            this.wmsParams[1.3 <= this._wmsVersion ? "crs" : "srs"] = this._crs.code;
            ngr.TileLayer.prototype.onAdd.call(this, a)
        },
        getTileUrl: function(a) {
            var c = this._map,
                e = this.options.tileSize,
                f = a.multiplyBy(e),
                e = f.add([e, e]),
                f = this._crs.project(c.unproject(f, a.z)),
                c = this._crs.project(c.unproject(e, a.z)),
                c = 1.3 <= this._wmsVersion && this._crs === ngr.CRS.EPSG4326 ? [c.y, f.x, f.y, c.x].join() : [f.x, c.y, c.x, f.y].join();
            a = ngr.Util.template(this._url, {
                s: this._getSubdomain(a)
            });
            return a + ngr.Util.getParamString(this.wmsParams, a, !0) + "&BBOX=" + c
        },
        setParams: function(a, c) {
            ngr.extend(this.wmsParams, a);
            c || this.redraw();
            return this
        }
    });
    ngr.tileLayer.wms = function(a, c) {
        return new ngr.TileLayer.WMS(a, c)
    };
    ngr.TileLayer.Canvas = ngr.TileLayer.extend({
        options: {
            async: !1
        },
        initialize: function(a) {
            ngr.setOptions(this, a)
        },
        redraw: function() {
            this._map && (this._reset({
                hard: !0
            }), this._update());
            for (var a in this._tiles) this._redrawTile(this._tiles[a]);
            return this
        },
        _redrawTile: function(a) {
            this.drawTile(a, a._tilePoint, this._map._zoom)
        },
        _createTile: function() {
            var a = ngr.DomUtil.create("canvas", "ngr-tile");
            a.width = a.height = this.options.tileSize;
            a.onselectstart = a.onmousemove = ngr.Util.falseFn;
            return a
        },
        _loadTile: function(a, c) {
            a._layer = this;
            a._tilePoint = c;
            this._redrawTile(a);
            this.options.async || this.tileDrawn(a)
        },
        drawTile: function() {},
        tileDrawn: function(a) {
            this._tileOnLoad.call(a)
        }
    });
    ngr.tileLayer.canvas = function(a) {
        return new ngr.TileLayer.Canvas(a)
    };

    ///-------------------------------------------Image Overlay ------------------------------------
    ngr.ImageOverlay =
        ngr.Class.extend({
            includes: ngr.Mixin.Events,
            options: {
                opacity: 1
            },
            initialize: function(a, c, e) {
                this._url = a;
                this._bounds = ngr.latLngBounds(c);
                ngr.setOptions(this, e)
            },
            onAdd: function(a) {
                this._map = a;
                this._image || this._initImage();
                a._panes.overlayPane.appendChild(this._image);
                a.on("viewreset", this._reset, this);
                if (a.options.zoomAnimation && ngr.Browser.any3d) a.on("zoomanim", this._animateZoom, this);
                this._reset()
            },
            onRemove: function(a) {
                a.getPanes().overlayPane.removeChild(this._image);
                a.off("viewreset", this._reset, this);
                a.options.zoomAnimation &&
                a.off("zoomanim", this._animateZoom, this)
            },
            addTo: function(a) {
                a.addLayer(this);
                return this
            },
            setOpacity: function(a) {
                this.options.opacity = a;
                this._updateOpacity();
                return this
            },
            bringToFront: function() {
                this._image && this._map._panes.overlayPane.appendChild(this._image);
                return this
            },
            bringToBack: function() {
                var a = this._map._panes.overlayPane;
                this._image && a.insertBefore(this._image, a.firstChild);
                return this
            },
            setUrl: function(a) {
                this._url = a;
                this._image.src = this._url
            },
            getAttribution: function() {
                return this.options.attribution
            },
            _initImage: function() {
                this._image = ngr.DomUtil.create("img", "ngr-image-layer");
                this._map.options.zoomAnimation && ngr.Browser.any3d ? ngr.DomUtil.addClass(this._image, "ngr-zoom-animated") : ngr.DomUtil.addClass(this._image, "ngr-zoom-hide");
                this._updateOpacity();
                ngr.extend(this._image, {
                    galleryimg: "no",
                    onselectstart: ngr.Util.falseFn,
                    onmousemove: ngr.Util.falseFn,
                    onload: ngr.bind(this._onImageLoad, this),
                    src: this._url
                })
            },
            _animateZoom: function(a) {
                var c = this._map,
                    e = this._image,
                    f = c.getZoomScale(a.zoom),
                    d = this._bounds.getNorthWest(),
                    g = this._bounds.getSouthEast(),
                    d = c._latLngToNewLayerPoint(d, a.zoom, a.center);
                a = c._latLngToNewLayerPoint(g, a.zoom, a.center)._subtract(d);
                a = d._add(a._multiplyBy(.5 * (1 - 1 / f)));
                e.style[ngr.DomUtil.TRANSFORM] = ngr.DomUtil.getTranslateString(a) + " scale(" + f + ") "
            },
            _reset: function() {
                var a = this._image,
                    c = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                    e = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(c);
                ngr.DomUtil.setPosition(a, c);
                a.style.width = e.x + "px";
                a.style.height = e.y + "px"
            },
            _onImageLoad: function() {
                this.fire("load")
            },
            _updateOpacity: function() {
                ngr.DomUtil.setOpacity(this._image, this.options.opacity)
            }
        });
    ngr.imageOverlay = function(a, c, e) {
        return new ngr.ImageOverlay(a, c, e)
    };

    ///--------------------------------------Icon---------------------------------
    ngr.Icon = ngr.Class.extend({
        options: {
            className: ""
        },
        initialize: function(a) {
            ngr.setOptions(this, a)
        },
        createIcon: function(a) {
            return this._createIcon("icon", a)
        },
        createShadow: function(a) {
            return this._createIcon("shadow", a)
        },
        _createIcon: function(a, c) {
            var b = this._getIconUrl(a);
            if (!b) {
                if ("icon" === a) throw Error("iconUrl not set in Icon options (see the docs).");
                return null
            }
            b =
                c && "IMG" === c.tagName ? this._createImg(b, c) : this._createImg(b);
            this._setIconStyles(b, a);
            return b
        },
        _setIconStyles: function(a, c) {
            var b = this.options,
                f = this._getIconSize(c),
                d = this._getIconAnchor(c);
            a.className = "ngr-marker-" + c + " " + b.className;
            d && (a.style.marginLeft = -d.x + "px", a.style.marginTop = -d.y + "px");
            f && (a.style.width = f.x + "px", a.style.height = f.y + "px")
        },
        _createImg: function(a, c) {
            c = c || g.createElement("img");
            c.src = a;
            return c
        },
        _getIconUrl: function(a) {
            return ngr.Browser.retina && this.options[a + "RetinaUrl"] ? this.options[a +
            "RetinaUrl"] : this.options[a + "Url"]
        },
        _getIconAnchor: function(a) {
            var c = this.options,
                e = this._getIconSize(a);
            a = "shadow" === a ? ngr.point(c.shadowAnchor || c.iconAnchor) : ngr.point(c.iconAnchor);
            !a && e && (a = e.divideBy(2, !0));
            return a
        },
        _getIconSize: function(a) {
            return ngr.point(this.options[a + "Size"])
        }
    });
    ngr.icon = function(a) {
        return new ngr.Icon(a)
    };
    ngr.Icon.Default = ngr.Icon.extend({
        options: {
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        },
        _getIconUrl: function(a) {
            var c = a + "Url";
            if (this.options[c]) return this.options[c];
            ngr.Browser.retina && "icon" === a && (a += "-2x");
            c = ngr.Icon.Default.imagePath;
            if (!c) throw Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
            return c + "/marker-" + a + ".png"
        }
    });
    ngr.Icon.Default.imagePath = function() {
        var a = g.getElementsByTagName("script"),
            c = /[\/^](PalmapSDK|ngr)[\-\._]?([\w\-\._]*)\.js\??/i,
            b, f, d, h;
        b = 0;
        for (f = a.length; b < f; b++)
            if (d = a[b].src, h = d.match(c)) return a = d.split(c)[0], (a ? a + "/" : "") + "images"
    }();
    ngr.Icon.Location = ngr.Icon.extend({
        options: {
            iconSize: [20, 20],
            showHalo: !0
        },
        _getIconUrl: function(a) {
            var c =
                a + "Url";
            if (this.options[c]) return this.options[c];
            c = ngr.Icon.Default.imagePath;
            if (!c) throw Error("Couldn't autodetect NGR.Icon.Default.imagePath, set it manually.");
            if ("icon" == a) return c + "/marker-location.png"
        },
        _setIconStyles: function(a, c) {
            var b = this.options,
                f = this._getIconSize(c),
                d = this._getIconAnchor(c);
            a.className = "ngr-marker-" + c + " ngr-trackBall " + b.className + (b.showHalo ? " ngr-halo" : "");
            this.setActiveStatus = function(c) {
                var b = a.className.split(" "),
                    e = b.indexOf("ngr-gray");
                0 > e ^ c && (c ? b.splice(e, 1) :
                    b.push("ngr-gray"));
                a.className = b.join(" ")
            };
            d && (a.style.marginLeft = -d.x + "px", a.style.marginTop = -d.y + "px");
            f && (a.style.width = f.x + "px", a.style.height = f.y + "px")
        }
    });
    ngr.icon.location = function(a) {
        return new ngr.Icon.Location(a)
    };

    ///------------------------------ Marker ----------------------------------
    ngr.Marker = ngr.Class.extend({
        includes: ngr.Mixin.Events,
        options: {
            icon: new ngr.Icon.Default,
            title: "",
            alt: "",
            clickable: !0,
            draggable: !1,
            keyboard: !0,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: !1,
            riseOffset: 250
        },
        initialize: function(a, c) {
            ngr.setOptions(this, c);
            this._latlng = ngr.latLng(a)
        },
        onAdd: function(a) {
            this._map =
                a;
            a.on("viewreset", this.update, this);
            this._initIcon();
            this.update();
            this.fire("add");
            if (a.options.zoomAnimation && a.options.markerZoomAnimation) a.on("zoomanim", this._animateZoom, this)
        },
        addTo: function(a) {
            a.addLayer(this);
            return this
        },
        onRemove: function(a) {
            this.dragging && this.dragging.disable();
            this._removeIcon();
            this._removeShadow();
            this.fire("remove");
            a.off({
                viewreset: this.update,
                zoomanim: this._animateZoom
            }, this);
            this._map = null
        },
        getLatLng: function() {
            return this._latlng
        },
        setLatLng: function(a) {
            this._latlng =
                ngr.latLng(a);
            this.update();
            return this.fire("move", {
                latlng: this._latlng
            })
        },
        setZIndexOffset: function(a) {
            this.options.zIndexOffset = a;
            this.update();
            return this
        },
        setIcon: function(a) {
            this.options.icon = a;
            this._map && (this._initIcon(), this.update());
            this._popup && this.bindPopup(this._popup);
            return this
        },
        update: function() {
            if (this._icon) {
                var a = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(a)
            }
            return this
        },
        _initIcon: function() {
            var a = this.options,
                c = this._map,
                e = c.options.zoomAnimation && c.options.markerZoomAnimation ?
                    "ngr-zoom-animated" : "ngr-zoom-hide",
                f = a.icon.createIcon(this._icon),
                c = !1;
            f !== this._icon && (this._icon && this._removeIcon(), c = !0, a.title && (f.title = a.title), a.alt && (f.alt = a.alt));
            ngr.DomUtil.addClass(f, e);
            a.keyboard && (f.tabIndex = "0");
            this._icon = f;
            this._initInteraction();
            if (a.riseOnHover) ngr.DomEvent.on(f, "mouseover", this._bringToFront, this).on(f, "mouseout", this._resetZIndex, this);
            var f = a.icon.createShadow(this._shadow),
                d = !1;
            f !== this._shadow && (this._removeShadow(), d = !0);
            f && ngr.DomUtil.addClass(f, e);
            this._shadow =
                f;
            1 > a.opacity && this._updateOpacity();
            a = this._map._panes;
            c && a.markerPane.appendChild(this._icon);
            f && d && a.shadowPane.appendChild(this._shadow)
        },
        _removeIcon: function() {
            this.options.riseOnHover && ngr.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex);
            this._map._panes.markerPane.removeChild(this._icon);
            this._icon = null
        },
        _removeShadow: function() {
            this._shadow && this._map._panes.shadowPane.removeChild(this._shadow);
            this._shadow = null
        },
        _setPos: function(a) {
            ngr.DomUtil.setPosition(this._icon,
                a);
            this._shadow && ngr.DomUtil.setPosition(this._shadow, a);
            this._zIndex = a.y + this.options.zIndexOffset;
            this._resetZIndex()
        },
        _updateZIndex: function(a) {
            this._icon.style.zIndex = this._zIndex + a
        },
        _animateZoom: function(a) {
            a = this._map._latLngToNewLayerPoint(this._latlng, a.zoom, a.center).round();
            this._setPos(a)
        },
        _initInteraction: function() {
            if (this.options.clickable) {
                var a = this._icon,
                    c = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];
                ngr.DomUtil.addClass(a, "ngr-clickable");
                ngr.DomEvent.on(a, "click", this._onMouseClick,
                    this);
                ngr.DomEvent.on(a, "keypress", this._onKeyPress, this);
                for (var e = 0; e < c.length; e++) ngr.DomEvent.on(a, c[e], this._fireMouseEvent, this);
                ngr.Handler.MarkerDrag && (this.dragging = new ngr.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable())
            }
        },
        _onMouseClick: function(a) {
            var c = this.dragging && this.dragging.moved();
            (this.hasEventListeners(a.type) || c) && ngr.DomEvent.stopPropagation(a);
            c || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(a.type, {
                originalEvent: a,
                latlng: this._latlng
            })
        },
        _onKeyPress: function(a) {
            13 === a.keyCode && this.fire("click", {
                originalEvent: a,
                latlng: this._latlng
            })
        },
        _fireMouseEvent: function(a) {
            this.fire(a.type, {
                originalEvent: a,
                latlng: this._latlng
            });
            "contextmenu" === a.type && this.hasEventListeners(a.type) && ngr.DomEvent.preventDefault(a);
            "mousedown" !== a.type ? ngr.DomEvent.stopPropagation(a) : ngr.DomEvent.preventDefault(a)
        },
        setOpacity: function(a) {
            this.options.opacity = a;
            this._map && this._updateOpacity();
            return this
        },
        _updateOpacity: function() {
            ngr.DomUtil.setOpacity(this._icon,
                this.options.opacity);
            this._shadow && ngr.DomUtil.setOpacity(this._shadow, this.options.opacity)
        },
        _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset)
        },
        _resetZIndex: function() {
            this._updateZIndex(0)
        }
    });
    ngr.marker = function(a, c) {
        return new ngr.Marker(a, c)
    };
    ngr.RotatedMarker = ngr.Marker.extend({
        options: {
            angle: 0,
            indicateDirection: !1
        },
        initialize: function(a, c) {
            ngr.Marker.prototype.initialize.call(this, a, c);
            var e = this;
            this.deviceorientationHandler = function(a) {
                e.options.angle = a.webkitCompassHeading || (0 > a.alpha ?
                    -a.alpha : 360 - a.alpha);
                e.update()
            }
        },
        onAdd: function(a) {
            ngr.Marker.prototype.onAdd.call(this, a);
            d.addEventListener("deviceorientation", this.deviceorientationHandler, !1)
        },
        onRemove: function(a) {
            ngr.Marker.prototype.onRemove.call(this, a);
            d.removeEventListener("deviceorientation", this.deviceorientationHandler, !1)
        },
        _setPos: function(a) {
            ngr.Marker.prototype._setPos.call(this, a);
            if (ngr.DomUtil.TRANSFORM) this._icon.style[ngr.DomUtil.TRANSFORM] += " rotate(" + this.options.angle + "deg)";
            else if (ngr.Browser.ie) {
                var c = this.options.angle *
                    ngr.LatLng.DEG_TO_RAD;
                a = Math.cos(c);
                c = Math.sin(c);
                this._icon.style.filter += " progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11=" + a + ", M12=" + -c + ", M21=" + c + ", M22=" + a + ")"
            }
        }
    });
    ngr.rotatedMarker = function(a, c) {
        return new ngr.RotatedMarker(a, c)
    };
    ngr.CanvasMarker = ngr.Class.extend(d.NGR_PREFER_CANVAS ? {
        includes: [ngr.Mixin.Events],
        statics: {
            _imgCache: {}
        },
        options: {
            icon: new ngr.Icon.Default,
            clickable: !1,
            opacity: 1,
            rotate: 0,
            fixedSize: !1
        },
        initialize: function(a, c) {
            ngr.Browser.canvas ? (ngr.setOptions(this, c), this.latlng =
                ngr.latLng(a), this.options.icon && this._loadImage()) : console.warn("Your browser doesn't support canvas.")
        },
        onAdd: function(a) {
            this._map = a;
            this._ctx = a._canvasCtx;
            a._pathRoot || a._initPathRoot();
            this._initialized || (this._initEvents(), this._initialized = !0);
            this.options.fixedSize && this._parseSize();
            this.fire("add");
            a.on({
                viewreset: this.projectLatLngs,
                moveend: this._updateImage
            }, this);
            this.redraw()
        },
        onRemove: function(a) {
            a.off("viewreset", this.projectLatLngs, this).off("moveend", this._updateImage, this);
            this._requestUpdate();
            this.fire("remove");
            this._unloadEvents();
            this._map = null
        },
        addTo: function(a) {
            a.addLayer(this);
            return this
        },
        projectLatLngs: function() {
            var a = this._map.latLngToLayerPoint(this.latlng),
                c;
            this._iconLatLngBounds ? (c = this._map.latLngToLayerPoint(this._iconLatLngBounds.getSouthEast()), this._leftTopPoint = this._map.latLngToLayerPoint(this._iconLatLngBounds.getNorthWest()), this._iconSize = c.subtract(this._leftTopPoint), this._imageBounds = ngr.bounds(this._leftTopPoint, c)) : this._iconImg && (this._leftTopPoint = a.subtract(this.options.icon._getIconAnchor("icon")),
                this._iconSize = ngr.point(this.options.icon.options.iconSize), this._imageBounds = ngr.bounds(this._leftTopPoint, this._leftTopPoint.add(this._iconSize)));
            this._shadowLatLngBounds ? (c = this._map.latLngToLayerPoint(this._shadowLatLngBounds.getSouthEast()), this._leftTopShadowPoint = this._map.latLngToLayerPoint(this._shadowLatLngBounds.getNorthWest()), this._shadowSize = c.subtract(this._leftTopShadowPoint)) : this._shadowImg && (this._leftTopShadowPoint = a.subtract(this.options.icon._getIconAnchor("shadow")), this._shadowSize =
                ngr.point(this.options.icon.options.shadowSize))
        },
        redraw: function() {
            this._map && (this.projectLatLngs(), this._requestUpdate());
            return this
        },
        getLatLng: function() {
            return this.latlng
        },
        setLatLng: function(a) {
            this.latlng = ngr.latLng(a);
            this._parseSize();
            this.redraw();
            return this
        },
        setFixedSize: function(a) {
            (this.options.fixedSize = a) ? this._parseSize(): this._shadowLatLngBounds = this._iconLatLngBounds = null;
            this.redraw();
            return this
        },
        setStyle: function(a) {
            ngr.setOptions(this, a);
            this._map && (this._loadImage(), this.setFixedSize(this.options.fixedSize),
                this.projectLatLngs(), this._requestUpdate());
            return this
        },
        _initEvents: function() {
            if (this.options.clickable) this._map.on("click", this._onClick, this)
        },
        _unloadEvents: function() {
            this.options.clickable && this._map.off("click", this._onClick, this)
        },
        _loadImage: function() {
            var a = this.options.icon._getIconUrl("icon"),
                c = this.options.icon._getIconUrl("shadow");
            a in ngr.CanvasMarker._imgCache ? this._iconImg = ngr.CanvasMarker._imgCache[a] : a && (this._loadingIcon = !0, this._iconImg = new Image, this._iconImg.addEventListener("load",
                function(c) {
                    return function() {
                        c._loadingIcon = !1;
                        ngr.CanvasMarker._imgCache[a] = c._iconImg;
                        c._map && !c._loadingShadow && c.redraw()
                    }
                }(this), !1), this._iconImg.addEventListener("error", function(c) {
                return function() {
                    c._loadingIcon = !1;
                    ngr.CanvasMarker._imgCache[a] = null;
                    c._iconImg = null
                }
            }(this), !1), this._iconImg.src = a);
            c in ngr.CanvasMarker._imgCache ? this._shadowImg = ngr.CanvasMarker._imgCache[c] : c && (this._loadingShadow = !0, this._shadowImg = new Image, this._shadowImg.addEventListener("load", function(a) {
                return function() {
                    a._loadingShadow = !1;
                    ngr.CanvasMarker._imgCache[c] = a._shadowImg;
                    a._map && !a._loadingIcon && a.redraw()
                }
            }(this), !1), this._shadowImg.addEventListener("error", function(c) {
                return function() {
                    c._loadingShadow = !1;
                    ngr.CanvasMarker._imgCache[a] = null;
                    c._shadowImg = null
                }
            }(this), !1), this._shadowImg.src = c)
        },
        _onClick: function(a) {
            this._containsPoint(a.layerPoint) && this.fire("click", a)
        },
        _updateImage: function() {
            this._ctx.save();
            this._ctx.globalAlpha = this.options.opacity;
            if (this.options.rotate) {
                var a = this._imageBounds.getCenter();
                this._ctx.translate(a.x,
                    a.y);
                this._ctx.rotate(this.options.rotate);
                this._ctx.translate(-a.x, -a.y)
            }
            this._shadowImg && this._ctx.drawImage(this._shadowImg, this._leftTopShadowPoint.x, this._leftTopShadowPoint.y, this._shadowSize.x, this._shadowSize.y);
            this._iconImg && this._ctx.drawImage(this._iconImg, this._leftTopPoint.x, this._leftTopPoint.y, this._iconSize.x, this._iconSize.y);
            this._ctx.restore()
        },
        _containsPoint: function(a) {
            return this._imageBounds.contains(a)
        },
        _requestUpdate: function() {
            this._map && !ngr.CanvasMarker._updateRequest &&
            (ngr.CanvasMarker._updateRequest = ngr.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
        },
        _fireMapMoveEnd: function() {
            ngr.CanvasMarker._updateRequest = null;
            this.fire("moveend")
        },
        _parseSize: function() {
            if (this.options.fixedSize) {
                var a = this,
                    c = function(a) {
                        var c = /^(\d+|\d*\.\d+)\s*(m|px)?$/i.exec(a);
                        if (3 !== c.length) console.error('Wrong syntax "' + a + '" in fixedSize.');
                        else return {
                            value: parseFloat(c[1]),
                            unit: c[2] ? c[2] : "px"
                        }
                    },
                    e = function(e) {
                        if (e in a.options.fixedSize) {
                            var d = a.options.icon._getIconSize(e),
                                g = a.options.icon._getIconAnchor(e),
                                h = c(a.options.fixedSize[e][0]);
                            e = c(a.options.fixedSize[e][1]);
                            var k = g.x / d.x * h.value,
                                d = g.y / d.y * e.value,
                                n;
                            switch (h.unit + " " + e.unit) {
                                case "m m":
                                    n = ngr.CRS.EPSG3857.project(a.latlng);
                                    k = n.subtract([k, d]);
                                    h = k.add([h.value, e.value]);
                                    n = ngr.latLngBounds(ngr.CRS.EPSG3857.unproject(k), ngr.CRS.EPSG3857.unproject(h));
                                    break;
                                case "px px":
                                    n = a._map.latLngToLayerPoint(a.latlng);
                                    k = n.subtract([k, d]);
                                    h = k.add([h.value, e.value]);
                                    n = ngr.latLngBounds(a._map.layerPointToLatLng(k), a._map.layerPointToLatLng(h));
                                    break;
                                default:
                                    console.warn("Unsupported unit combination",
                                        h.unit + "+" + e.unit)
                            }
                            return n
                        }
                    };
                this._iconImg && "icon" in this.options.fixedSize && (this._iconLatLngBounds = e("icon"));
                this._shadowImg && "shadow" in this.options.fixedSize && (this._shadowLatLngBounds = e("shadow"))
            }
        }
    } : {});
    ngr.canvasmarker = function(a, c) {
        return new ngr.CanvasMarker(a, c)
    };
    ngr.CanvasLabel = ngr.Class.extend(d.NGR_PREFER_CANVAS ? {
        includes: [ngr.Mixin.Events],
        options: {
            opacity: 1,
            fill: !0,
            stroke: !1,
            color: "#000",
            fillOpacity: 1,
            fillColor: "#000",
            textAlign: "center",
            textBaseline: "middle",
            font: '13px/1.4 "Microsoft YaHei", "Helvetica Neue", Helvetica, STHeiTi, arial, sans-serif',
            textContent: null,
            boundPolygon: null
        },
        initialize: function(a, c) {
            ngr.Browser.canvas ? (ngr.setOptions(this, c), this.latlng = a) : console.warn("Your browser doesn't support canvas.")
        },
        onAdd: function(a) {
            this._map = a;
            this._ctx = a._canvasCtx;
            a._pathRoot || a._initPathRoot();
            this._initialized || (this._initialized = !0);
            this.fire("add");
            a.on({
                viewreset: this.projectLatLngs,
                moveend: this._updateLabel
            }, this);
            this.redraw()
        },
        onRemove: function(a) {
            a.off("viewreset", this.projectLatLngs, this).off("moveend", this._updateLabel, this);
            this._requestUpdate();
            this.fire("remove");
            this._map = null
        },
        addTo: function(a) {
            a.addLayer(this);
            return this
        },
        projectLatLngs: function() {
            this._centerPoint = this._map.latLngToLayerPoint(this.latlng)
        },
        redraw: function() {
            this._map && (this.projectLatLngs(), this._requestUpdate());
            return this
        },
        getLatLng: function() {
            return this.latlng
        },
        setLatLng: function(a) {
            this.latlng = a;
            this.redraw()
        },
        getContent: function() {
            return this.options.textContent
        },
        setContent: function(a) {
            this.options.textContent = a;
            this._requestUpdate()
        },
        setStyle: function(a) {
            ngr.setOptions(this,
                a);
            this._map && this._requestUpdate();
            return this
        },
        _requestUpdate: function() {
            this._map && !ngr.CanvasLabel._updateRequest && (ngr.CanvasLabel._updateRequest = ngr.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
        },
        _fireMapMoveEnd: function() {
            ngr.CanvasLabel._updateRequest = null;
            this.fire("moveend")
        },
        _updateLabel: function() {
            if (null != this.options.textContent) {
                var a = null;
                this.options.boundPolygon && (a = this.options.boundPolygon.getSize());
                var c = this._ctx,
                    b = this._centerPoint,
                    f = 2 > this._map.getMaxZoom() - this._map.getZoom();
                c.save();
                var d = this.options;
                c.beginPath();
                c.font = d.font;
                c.textAlign = d.textAlign;
                c.textBaseline = d.textBaseline;
                var g = c.measureText(d.textContent).width;
                d.stroke && (c.globalAlpha = d.opacity, c.strokeStyle = d.color, (f || !a || .9 * a.x > g) && c.strokeText(d.textContent, b.x, b.y, a ? .9 * a.x : g));
                d.fill && (c.globalAlpha = d.fillOpacity, c.fillStyle = d.fillColor || d.color, (f || !a || .9 * a.x > g) && c.fillText(d.textContent, b.x, b.y, a ? .9 * a.x : g));
                c.restore()
            }
        }
    } : {});
    ngr.canvaslabel = function(a, c) {
        return new ngr.CanvasLabel(a, c)
    };
    ngr.DivIcon = ngr.Icon.extend({
        options: {
            iconSize: [12,
                12
            ],
            className: "ngr-div-icon",
            html: !1
        },
        createIcon: function(a) {
            a = a && "DIV" === a.tagName ? a : g.createElement("div");
            var c = this.options;
            a.innerHTML = !1 !== c.html ? c.html : "";
            c.bgPos && (a.style.backgroundPosition = -c.bgPos.x + "px " + -c.bgPos.y + "px");
            this._setIconStyles(a, "icon");
            return a
        },
        createShadow: function() {
            return null
        }
    });
    ngr.divIcon = function(a) {
        return new ngr.DivIcon(a)
    };
    ngr.Map.mergeOptions({
        closePopupOnClick: !0
    });
    ngr.Popup = ngr.Class.extend({
        includes: ngr.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            autoPan: !0,
            closeButton: !0,
            offset: [0, 7],
            autoPanPadding: [5, 5],
            keepInView: !1,
            className: "",
            zoomAnimation: !0
        },
        initialize: function(a, c) {
            ngr.setOptions(this, a);
            this._source = c;
            this._animated = ngr.Browser.any3d && this.options.zoomAnimation;
            this._isOpen = !1
        },
        onAdd: function(a) {
            this._map = a;
            this._container || this._initLayout();
            var c = a.options.fadeAnimation;
            c && ngr.DomUtil.setOpacity(this._container, 0);
            a._panes.popupPane.appendChild(this._container);
            a.on(this._getEvents(), this);
            this.update();
            c && ngr.DomUtil.setOpacity(this._container, 1);
            this.fire("open");
            a.fire("popupopen", {
                popup: this
            });
            this._source && this._source.fire("popupopen", {
                popup: this
            })
        },
        addTo: function(a) {
            a.addLayer(this);
            return this
        },
        openOn: function(a) {
            a.openPopup(this);
            return this
        },
        onRemove: function(a) {
            a._panes.popupPane.removeChild(this._container);
            ngr.Util.falseFn(this._container.offsetWidth);
            a.off(this._getEvents(), this);
            a.options.fadeAnimation && ngr.DomUtil.setOpacity(this._container, 0);
            this._map = null;
            this.fire("close");
            a.fire("popupclose", {
                popup: this
            });
            this._source && this._source.fire("popupclose", {
                popup: this
            })
        },
        getLatLng: function() {
            return this._latlng
        },
        setLatLng: function(a) {
            this._latlng = ngr.latLng(a);
            this._map && (this._updatePosition(), this._adjustPan());
            return this
        },
        getContent: function() {
            return this._content
        },
        setContent: function(a) {
            this._content = a;
            this.update();
            return this
        },
        update: function() {
            this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
        },
        _getEvents: function() {
            var a = {
                viewreset: this._updatePosition
            };
            this._animated && (a.zoomanim = this._zoomAnimation);
            if ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) a.preclick = this._close;
            this.options.keepInView && (a.moveend = this._adjustPan);
            return a
        },
        _close: function() {
            this._map && this._map.closePopup(this)
        },
        _initLayout: function() {
            var a = this._container = ngr.DomUtil.create("div", "ngr-popup " + this.options.className + " ngr-zoom-" + (this._animated ? "animated" : "hide")),
                c;
            this.options.closeButton &&
            (c = this._closeButton = ngr.DomUtil.create("a", "ngr-popup-close-button", a), c.href = "#close", c.innerHTML = "&#215;", ngr.DomEvent.disableClickPropagation(c), ngr.DomEvent.on(c, "click", this._onCloseButtonClick, this));
            c = this._wrapper = ngr.DomUtil.create("div", "ngr-popup-content-wrapper", a);
            ngr.DomEvent.disableClickPropagation(c);
            this._contentNode = ngr.DomUtil.create("div", "ngr-popup-content", c);
            ngr.DomEvent.disableScrollPropagation(this._contentNode);
            ngr.DomEvent.on(c, "contextmenu", ngr.DomEvent.stopPropagation);
            this._tipContainer =
                ngr.DomUtil.create("div", "ngr-popup-tip-container", a);
            this._tip = ngr.DomUtil.create("div", "ngr-popup-tip", this._tipContainer)
        },
        _updateContent: function() {
            if (this._content) {
                if ("string" === typeof this._content) this._contentNode.innerHTML = this._content;
                else {
                    for (; this._contentNode.hasChildNodes();) this._contentNode.removeChild(this._contentNode.firstChild);
                    this._contentNode.appendChild(this._content)
                }
                this.fire("contentupdate")
            }
        },
        _updateLayout: function() {
            var a = this._contentNode,
                c = a.style;
            c.width = "";
            c.whiteSpace =
                "nowrap";
            var e = a.offsetWidth,
                e = Math.min(e, this.options.maxWidth),
                e = Math.max(e, this.options.minWidth);
            c.width = e + 1 + "px";
            c.whiteSpace = "";
            c.height = "";
            var e = a.offsetHeight,
                f = this.options.maxHeight;
            f && e > f ? (c.height = f + "px", ngr.DomUtil.addClass(a, "ngr-popup-scrolled")) : ngr.DomUtil.removeClass(a, "ngr-popup-scrolled");
            this._containerWidth = this._container.offsetWidth
        },
        _updatePosition: function() {
            if (this._map) {
                var a = this._map.latLngToLayerPoint(this._latlng),
                    c = this._animated,
                    e = ngr.point(this.options.offset);
                c && ngr.DomUtil.setPosition(this._container,
                    a);
                this._containerBottom = -e.y - (c ? 0 : a.y);
                this._containerLeft = -Math.round(this._containerWidth / 2) + e.x + (c ? 0 : a.x);
                this._container.style.bottom = this._containerBottom + "px";
                this._container.style.left = this._containerLeft + "px"
            }
        },
        _zoomAnimation: function(a) {
            a = this._map._latLngToNewLayerPoint(this._latlng, a.zoom, a.center);
            ngr.DomUtil.setPosition(this._container, a)
        },
        _adjustPan: function() {
            if (this.options.autoPan) {
                var a = this._map,
                    c = this._container.offsetHeight,
                    e = this._containerWidth,
                    f = new ngr.Point(this._containerLeft, -c - this._containerBottom);
                this._animated && f._add(ngr.DomUtil.getPosition(this._container));
                var f = a.layerPointToContainerPoint(f),
                    d = ngr.point(this.options.autoPanPadding),
                    g = ngr.point(this.options.autoPanPaddingTopLeft || d),
                    d = ngr.point(this.options.autoPanPaddingBottomRight || d),
                    h = a.getSize(),
                    k = 0,
                    n = 0;
                f.x + e + d.x > h.x && (k = f.x + e - h.x + d.x);
                0 > f.x - k - g.x && (k = f.x - g.x);
                f.y + c + d.y > h.y && (n = f.y + c - h.y + d.y);
                0 > f.y - n - g.y && (n = f.y - g.y);
                (k || n) && a.fire("autopanstart").panBy([k, n])
            }
        },
        _onCloseButtonClick: function(a) {
            this._close();
            ngr.DomEvent.stop(a)
        }
    });
    ngr.popup = function(a, c) {
        return new ngr.Popup(a, c)
    };
    ngr.Map.include({
        openPopup: function(a, c, e) {
            this.closePopup();
            a instanceof ngr.Popup || (a = (new ngr.Popup(e)).setLatLng(c).setContent(a));
            a._isOpen = !0;
            this._popup = a;
            return this.addLayer(a)
        },
        closePopup: function(a) {
            a && a !== this._popup || (a = this._popup, this._popup = null);
            a && (this.removeLayer(a), a._isOpen = !1);
            return this
        }
    });

    ///----------------------------------Marker------------------------------
    ngr.Marker.include({
        openPopup: function() {
            this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup));
            return this
        },
        closePopup: function() {
            this._popup && this._popup._close();
            return this
        },
        togglePopup: function() {
            this._popup && (this._popup._isOpen ? this.closePopup() : this.openPopup());
            return this
        },
        bindPopup: function(a, c) {
            var e = ngr.point(this.options.icon.options.popupAnchor || [0, 0]),
                e = e.add(ngr.Popup.prototype.options.offset);
            c && c.offset && (e = e.add(c.offset));
            c = ngr.extend({
                offset: e
            }, c);
            this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this),
                this._popupHandlersAdded = !0);
            a instanceof ngr.Popup ? (ngr.setOptions(a, c), this._popup = a) : this._popup = (new ngr.Popup(c, this)).setContent(a);
            return this
        },
        setPopupContent: function(a) {
            this._popup && this._popup.setContent(a);
            return this
        },
        unbindPopup: function() {
            this._popup && (this._popup = null, this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this), this._popupHandlersAdded = !1);
            return this
        },
        getPopup: function() {
            return this._popup
        },
        _movePopup: function(a) {
            this._popup.setLatLng(a.latlng)
        }
    });

    ///----------------------------------Layers------------------------------
    ngr.LayerGroup = ngr.Class.extend({
        initialize: function(a) {
            this._layers = {};
            var c, b;
            if (a)
                for (c = 0, b = a.length; c < b; c++) this.addLayer(a[c])
        },
        addLayer: function(a) {
            var c = this.getLayerId(a);
            this._layers[c] = a;
            this._map && this._map.addLayer(a);
            return this
        },
        removeLayer: function(a) {
            a = a in this._layers ? a : this.getLayerId(a);
            this._map && this._layers[a] && this._map.removeLayer(this._layers[a]);
            delete this._layers[a];
            return this
        },
        hasLayer: function(a) {
            return a ? a in this._layers || this.getLayerId(a) in this._layers : !1
        },
        clearLayers: function() {
            this.eachLayer(this.removeLayer,
                this);
            return this
        },
        invoke: function(a) {
            var c = Array.prototype.slice.call(arguments, 1),
                b, f;
            for (b in this._layers) f = this._layers[b], f[a] && f[a].apply(f, c);
            return this
        },
        onAdd: function(a) {
            this._map = a;
            this.eachLayer(a.addLayer, a)
        },
        onRemove: function(a) {
            this.eachLayer(a.removeLayer, a);
            this._map = null
        },
        addTo: function(a) {
            a.addLayer(this);
            return this
        },
        eachLayer: function(a, c) {
            for (var b in this._layers) a.call(c, this._layers[b]);
            return this
        },
        getLayer: function(a) {
            return this._layers[a]
        },
        getLayers: function() {
            var a = [],
                c;
            for (c in this._layers) a.push(this._layers[c]);
            return a
        },
        setZIndex: function(a) {
            return this.invoke("setZIndex", a)
        },
        getLayerId: function(a) {
            return ngr.stamp(a)
        }
    });
    ngr.layerGroup = function(a) {
        return new ngr.LayerGroup(a)
    };
    ngr.FeatureGroup = ngr.LayerGroup.extend({
        includes: ngr.Mixin.Events,
        statics: {
            EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
        },
        addLayer: function(a) {
            if (this.hasLayer(a)) return this;
            if ("on" in a) a.on(ngr.FeatureGroup.EVENTS, this._propagateEvent, this);
            ngr.LayerGroup.prototype.addLayer.call(this,
                a);
            this._popupContent && a.bindPopup && a.bindPopup(this._popupContent, this._popupOptions);
            return this.fire("layeradd", {
                layer: a
            })
        },
        removeLayer: function(a) {
            if (!this.hasLayer(a)) return this;
            a in this._layers && (a = this._layers[a]);
            a.off(ngr.FeatureGroup.EVENTS, this._propagateEvent, this);
            ngr.LayerGroup.prototype.removeLayer.call(this, a);
            this._popupContent && this.invoke("unbindPopup");
            return this.fire("layerremove", {
                layer: a
            })
        },
        bindPopup: function(a, c) {
            this._popupContent = a;
            this._popupOptions = c;
            return this.invoke("bindPopup",
                a, c)
        },
        openPopup: function(a) {
            for (var c in this._layers) {
                this._layers[c].openPopup(a);
                break
            }
            return this
        },
        setStyle: function(a) {
            return this.invoke("setStyle", a)
        },
        bringToFront: function() {
            return this.invoke("bringToFront")
        },
        bringToBack: function() {
            return this.invoke("bringToBack")
        },
        getBounds: function() {
            var a = new ngr.LatLngBounds;
            this.eachLayer(function(c) {
                a.extend(c instanceof ngr.Marker ? c.getLatLng() : c.getBounds())
            });
            return a
        },
        _propagateEvent: function(a) {
            a = ngr.extend({
                layer: a.target,
                target: this
            }, a);
            this.fire(a.type,
                a)
        }
    });
    ngr.featureGroup = function(a) {
        return new ngr.FeatureGroup(a)
    };

    ///----------------------------------Path---------------------------------
    ngr.Path = ngr.Class.extend({
        includes: [ngr.Mixin.Events],
        statics: {
            CLIP_PADDING: function() {
                var a = ((ngr.Browser.mobile ? 1280 : 2E3) / Math.max(d.outerWidth, d.outerHeight) - 1) / 2;
                return Math.max(0, Math.min(.5, a))
            }()
        },
        options: {
            stroke: !0,
            color: "#0033ff",
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            weight: 5,
            opacity: .5,
            fill: !1,
            fillColor: null,
            fillOpacity: .2,
            clickable: !0
        },
        initialize: function(a) {
            ngr.setOptions(this, a)
        },
        onAdd: function(a) {
            this._map = a;
            this._container ||
            (this._initElements(), this._initEvents());
            this.projectLatlngs();
            this._updatePath();
            this._container && this._map._pathRoot.appendChild(this._container);
            this.fire("add");
            a.on({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this)
        },
        addTo: function(a) {
            a.addLayer(this);
            return this
        },
        onRemove: function(a) {
            a._pathRoot.removeChild(this._container);
            this.fire("remove");
            this._map = null;
            ngr.Browser.vml && (this._fill = this._stroke = this._container = null);
            a.off({
                    viewreset: this.projectLatlngs,
                    moveend: this._updatePath
                },
                this)
        },
        projectLatlngs: function() {},
        setStyle: function(a) {
            ngr.setOptions(this, a);
            this._container && this._updateStyle();
            return this
        },
        redraw: function() {
            this._map && (this.projectLatlngs(), this._updatePath());
            return this
        }
    });
    ngr.Map.include({
        _updatePathViewport: function() {
            var a = ngr.Path.CLIP_PADDING; //padding ratio
            var c = this.getSize(); //map size
            var e = ngr.DomUtil.getPosition(this._mapPane).multiplyBy(-1)._subtract(c.multiplyBy(a)._round());  //left postion
            a = e.add(c.multiplyBy(1 + 2 * a)._round()); //new size
            this._pathViewport = new ngr.Bounds(e, a); //viewport rect
            //alert("updatePathViewport: viewport size ("+ c.x+", "+ c.y+")");
        }
    });
    ///-----------------------------SVG Path-------------------------------
    ngr.Path.SVG_NS = "http://www.w3.org/2000/svg";
    ngr.Browser.svg = !(!g.createElementNS || !g.createElementNS(ngr.Path.SVG_NS, "svg").createSVGRect);
    ngr.Path = ngr.Path.extend({
        statics: {
            SVG: ngr.Browser.svg
        },
        bringToFront: function() {
            var a = this._map._pathRoot,
                c = this._container;
            c && a.lastChild !== c && a.appendChild(c);
            return this
        },
        bringToBack: function() {
            var a = this._map._pathRoot,
                c = this._container,
                b = a.firstChild;
            c && b !== c && a.insertBefore(c, b);
            return this
        },
        getPathString: function() {},
        _createElement: function(a) {
            return g.createElementNS(ngr.Path.SVG_NS, a)
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._initPath();
            this._initStyle()
        },
        _initPath: function() {
            this._container = this._createElement("g");
            this._path = this._createElement("path");
            this.options.className && ngr.DomUtil.addClass(this._path, this.options.className);
            this._container.appendChild(this._path)
        },
        _initStyle: function() {
            this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round"));
            this.options.fill && this._path.setAttribute("fill-rule", "evenodd");
            this.options.pointerEvents && this._path.setAttribute("pointer-events",
                this.options.pointerEvents);
            this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none");
            this._updateStyle()
        },
        _updateStyle: function() {
            this.options.stroke ? (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"),
            this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap), this.options.lineJoin && this._path.setAttribute("stroke-linejoin", this.options.lineJoin)) : this._path.setAttribute("stroke", "none");
            this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
        },
        _updatePath: function() {
            var a = this.getPathString();
            a || (a = "M0 0");
            this._path.setAttribute("d",
                a)
        },
        _initEvents: function() {
            if (this.options.clickable) {
                !ngr.Browser.svg && ngr.Browser.vml || ngr.DomUtil.addClass(this._path, "ngr-clickable");
                ngr.DomEvent.on(this._container, "click", this._onMouseClick, this);
                for (var a = "dblclick mousedown mouseover mouseout mousemove contextmenu".split(" "), c = 0; c < a.length; c++) ngr.DomEvent.on(this._container, a[c], this._fireMouseEvent, this)
            }
        },
        _onMouseClick: function(a) {
            this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(a)
        },
        _fireMouseEvent: function(a) {
            if (this.hasEventListeners(a.type)) {
                var c =
                        this._map,
                    e = c.mouseEventToContainerPoint(a),
                    f = c.containerPointToLayerPoint(e),
                    c = c.layerPointToLatLng(f);
                this.fire(a.type, {
                    latlng: c,
                    layerPoint: f,
                    containerPoint: e,
                    originalEvent: a
                });
                "contextmenu" === a.type && ngr.DomEvent.preventDefault(a);
                "mousemove" !== a.type && ngr.DomEvent.stopPropagation(a)
            }
        }
    });
    ngr.Map.include({
        _initPathRoot: function() {
            this._pathRoot || (this._pathRoot = ngr.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && ngr.Browser.any3d ? (ngr.DomUtil.addClass(this._pathRoot,
                "ngr-zoom-animated"), this.on({
                zoomanim: this._animatePathZoom,
                zoomend: this._endPathZoom
            })) : ngr.DomUtil.addClass(this._pathRoot, "ngr-zoom-hide"), this.on("moveend", this._updateSvgViewport), this._updateSvgViewport())
        },
        _animatePathZoom: function(a) {
            var c = this.getZoomScale(a.zoom);
            a = this._getCenterOffset(a.center)._multiplyBy(-c)._add(this._pathViewport.min);
            this._pathRoot.style[ngr.DomUtil.TRANSFORM] = ngr.DomUtil.getTranslateString(a) + " scale(" + c + ") ";
            this._pathZooming = !0
        },
        _endPathZoom: function() {
            this._pathZooming = !1
        },
        _updateSvgViewport: function() {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var a = this._pathViewport,
                    c = a.min,
                    e = a.max,
                    a = e.x - c.x,
                    e = e.y - c.y,
                    f = this._pathRoot,
                    d = this._panes.overlayPane;
                ngr.Browser.mobileWebkit && d.removeChild(f);
                ngr.DomUtil.setPosition(f, c);
                f.setAttribute("width", a);
                f.setAttribute("height", e);
                f.setAttribute("viewBox", [c.x, c.y, a, e].join(" "));
                ngr.Browser.mobileWebkit && d.appendChild(f)
            }
        }
    });

    ///-----------------------------------bind pop up------------------------------------
    ngr.Path.include({
        bindPopup: function(a, c) {
            if (a instanceof ngr.Popup) this._popup = a;
            else {
                if (!this._popup ||
                    c) this._popup = new ngr.Popup(c, this);
                this._popup.setContent(a)
            }
            this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this), this._popupHandlersAdded = !0);
            return this
        },
        unbindPopup: function() {
            this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1);
            return this
        },
        openPopup: function(a) {
            this._popup && (a = a || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)], this._openPopup({
                latlng: a
            }));
            return this
        },
        closePopup: function() {
            this._popup && this._popup._close();
            return this
        },
        _openPopup: function(a) {
            this._popup.setLatLng(a.latlng);
            this._map.openPopup(this._popup)
        }
    });
    ///-----------------------------------vml path --------------------------------------
    ngr.Browser.vml = !ngr.Browser.svg && function() {
        try {
            var a = g.createElement("div");
            a.innerHTML = '<v:shape adj="1"/>';
            var c = a.firstChild;
            c.style.behavior = "url(#default#VML)";
            return c && "object" === typeof c.adj
        } catch (b) {
            return !1
        }
    }();
    ngr.Path = ngr.Browser.svg || !ngr.Browser.vml ? ngr.Path : ngr.Path.extend({
        statics: {
            VML: !0,
            CLIP_PADDING: .02
        },
        _createElement: function() {
            try {
                return g.namespaces.add("lvml",
                    "urn:schemas-microsoft-com:vml"),
                    function(a) {
                        return g.createElement("<lvml:" + a + ' class="lvml">')
                    }
            } catch (a) {
                return function(a) {
                    return g.createElement("<" + a + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                }
            }
        }(),
        _initPath: function() {
            var a = this._container = this._createElement("shape");
            ngr.DomUtil.addClass(a, "ngr-vml-shape" + (this.options.className ? " " + this.options.className : ""));
            this.options.clickable && ngr.DomUtil.addClass(a, "ngr-clickable");
            a.coordsize = "1 1";
            this._path = this._createElement("path");
            a.appendChild(this._path);
            this._map._pathRoot.appendChild(a)
        },
        _initStyle: function() {
            this._updateStyle()
        },
        _updateStyle: function() {
            var a = this._stroke,
                c = this._fill,
                e = this.options,
                f = this._container;
            f.stroked = e.stroke;
            f.filled = e.fill;
            e.stroke ? (a || (a = this._stroke = this._createElement("stroke"), a.endcap = "round", f.appendChild(a)), a.weight = e.weight + "px", a.color = e.color, a.opacity = e.opacity, a.dashStyle = e.dashArray ? ngr.Util.isArray(e.dashArray) ? e.dashArray.join(" ") : e.dashArray.replace(/( *, *)/g, " ") : "", e.lineCap && (a.endcap = e.lineCap.replace("butt",
                "flat")), e.lineJoin && (a.joinstyle = e.lineJoin)) : a && (f.removeChild(a), this._stroke = null);
            e.fill ? (c || (c = this._fill = this._createElement("fill"), f.appendChild(c)), c.color = e.fillColor || e.color, c.opacity = e.fillOpacity) : c && (f.removeChild(c), this._fill = null)
        },
        _updatePath: function() {
            var a = this._container.style;
            a.display = "none";
            this._path.v = this.getPathString() + " ";
            a.display = ""
        }
    });
    ngr.Map.include(ngr.Browser.svg || !ngr.Browser.vml ? {} : {
        _initPathRoot: function() {
            if (!this._pathRoot) {
                var a = this._pathRoot = g.createElement("div");
                a.className = "ngr-vml-container";
                this._panes.overlayPane.appendChild(a);
                this.on("moveend", this._updatePathViewport);
                this._updatePathViewport()
            }
        }
    });

    ///-----------------------------------canvas path -----------------------------------
    ngr.Browser.canvas = !!g.createElement("canvas").getContext;
    ngr.Path = ngr.Path.SVG && !d.NGR_PREFER_CANVAS || !ngr.Browser.canvas ? ngr.Path : ngr.Path.extend({
        statics: {
            CANVAS: !0,
            SVG: !1
        },
        redraw: function() {
            this._map && (this.projectLatlngs(), this._requestUpdate());
            return this
        },
        setStyle: function(a) {
            ngr.setOptions(this, a);
            this._map && (this._updateStyle(), this._requestUpdate());
            return this
        },
        onRemove: function(a) {
            a.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this);
            this.options.clickable && (this._map.off("click", this._onClick, this), this._map.off("mousemove", this._onMouseMove, this));
            this._requestUpdate();
            this.fire("remove");
            this._map = null
        },
        _requestUpdate: function() {
            this._map && !ngr.Path._updateRequest && (ngr.Path._updateRequest = ngr.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
        },
        _fireMapMoveEnd: function() {
            ngr.Path._updateRequest = null;
            this.fire("moveend")
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._ctx = this._map._canvasCtx
        },
        _updateStyle: function() {
            var options = this.options;
            options.stroke && (this._ctx.lineWidth = options.weight, this._ctx.strokeStyle = options.color);
            options.fill && (this._ctx.fillStyle = options.fillColor || options.color)
        },
        _drawPath: function() {
            var i = 0;
            var j, e, f, d, g, h = this.options.weight % 2 / 2;
            this._ctx.beginPath();
            for (e = this._parts.length; i < e; i++) {
                j = 0;
                for (f = this._parts[i].length; j < f; j++) {
                    d = this._parts[i][j];
                    g = (0 === j ? "move" : "line") + "To", this._ctx[g](d.x + h, d.y + h);
                }
                this instanceof ngr.Polygon && this._ctx.closePath()
            }
        },
        _checkIfEmpty: function() {
            return !this._parts.length
        },
        _updatePath: function() {
            if (!this._checkIfEmpty()) {
                var a = this._ctx,
                    b = this.options;
                this._drawPath();
                a.save();
                this._updateStyle();
                b.fill && (a.globalAlpha = b.fillOpacity, a.fill());
                b.stroke && (a.globalAlpha = b.opacity, a.stroke());
                a.restore()
            }
        },
        _initEvents: function() {
            this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this), this._map.on("click", this._onClick, this))
        },
        _onClick: function(a) {
            this._containsPoint(a.layerPoint) && this.fire("click", a)
        },
        _onMouseMove: function(a) {
            this._map && !this._map._animatingZoom &&
            (this._containsPoint(a.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer", this._mouseInside = !0, this.fire("mouseover", a)) : this._mouseInside && (this._ctx.canvas.style.cursor = "", this._mouseInside = !1, this.fire("mouseout", a)))
        }
    });
    ngr.Map.include(ngr.Path.SVG && !d.NGR_PREFER_CANVAS || !ngr.Browser.canvas ? {} : {
        _initPathRoot: function() {
            var a = this._pathRoot,
                b;
            a || (a = this._pathRoot = g.createElement("canvas"), a.style.position = "absolute", b = this._canvasCtx = a.getContext("2d"), b.lineCap = "round", b.lineJoin = "round", this._panes.overlayPane.appendChild(a),
            this.options.zoomAnimation && (this._pathRoot.className = "ngr-zoom-animated", this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport())
        },
        _updateCanvasViewport: function() {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var a = this._pathViewport,
                    c = a.min,  //min
                    a = a.max.subtract(c),  //real width and height
                    e = this._pathRoot; //canvas dom
                ngr.DomUtil.setPosition(e, c);
                var f = d.devicePixelRatio || 1,
                    f = (ngr.Browser.mobile && !ngr.Browser.android || ngr.Browser.android23) &&
                    5E6 < a.x * a.y * f * f ? 1 : f;
                e.width = a.x * f;  //gm: canvas width
                e.height = a.y * f; //gm: canvas height
                1 != f && (e.style.width = a.x + "px", e.style.height = a.y + "px", e.getContext("2d").scale(f, f)); //gm: style width and height. scale
                e.getContext("2d").translate(-c.x, -c.y)
                //alert("updateCanvasViewport: dpr:"+f+",canvas size:("+ e.width+", " + e.height +")")
            }
        }
    });

    ///--------------------------------Line Utility----------------------------------
    ngr.LineUtil = {
        simplify: function(a, b) {
            if (!b || !a.length) return a.slice();
            var e = b * b;
            a = this._reducePoints(a, e);
            return a = this._simplifyDP(a, e)
        },
        pointToSegmentDistance: function(a, b, e) {
            return Math.sqrt(this._sqClosestPointOnSegment(a, b, e, !0))
        },
        closestPointOnSegment: function(a, b, e) {
            return this._sqClosestPointOnSegment(a, b, e)
        },
        _simplifyDP: function(a,
                              b) {
            var e = a.length,
                f = new(typeof Uint8Array !== h + "" ? Uint8Array : Array)(e);
            f[0] = f[e - 1] = 1;
            this._simplifyDPStep(a, f, b, 0, e - 1);
            var d, g = [];
            for (d = 0; d < e; d++) f[d] && g.push(a[d]);
            return g
        },
        _simplifyDPStep: function(a, b, e, f, d) {
            var g = 0,
                h, k, n;
            for (k = f + 1; k <= d - 1; k++) n = this._sqClosestPointOnSegment(a[k], a[f], a[d], !0), n > g && (h = k, g = n);
            g > e && (b[h] = 1, this._simplifyDPStep(a, b, e, f, h), this._simplifyDPStep(a, b, e, h, d))
        },
        _reducePoints: function(a, b) {
            for (var e = [a[0]], f = 1, d = 0, g = a.length; f < g; f++) this._sqDist(a[f], a[d]) > b && (e.push(a[f]),
                d = f);
            d < g - 1 && e.push(a[g - 1]);
            return e
        },
        clipSegment: function(a, b, e, f) {
            f = f ? this._lastCode : this._getBitCode(a, e);
            var d = this._getBitCode(b, e),
                g, h, k;
            for (this._lastCode = d;;)
                if (f | d) {
                    if (f & d) return !1;
                    g = f || d;
                    h = this._getEdgeIntersection(a, b, g, e);
                    k = this._getBitCode(h, e);
                    g === f ? (a = h, f = k) : (b = h, d = k)
                } else return [a, b]
        },
        _getEdgeIntersection: function(a, c, e, f) {
            var d = c.x - a.x;
            c = c.y - a.y;
            var g = f.min;
            f = f.max;
            if (e & 8) return new ngr.Point(a.x + d * (f.y - a.y) / c, f.y);
            if (e & 4) return new ngr.Point(a.x + d * (g.y - a.y) / c, g.y);
            if (e & 2) return new ngr.Point(f.x,
                a.y + c * (f.x - a.x) / d);
            if (e & 1) return new ngr.Point(g.x, a.y + c * (g.x - a.x) / d)
        },
        _getBitCode: function(a, b) {
            var e = 0;
            a.x < b.min.x ? e |= 1 : a.x > b.max.x && (e |= 2);
            a.y < b.min.y ? e |= 4 : a.y > b.max.y && (e |= 8);
            return e
        },
        _sqDist: function(a, b) {
            var e = b.x - a.x,
                f = b.y - a.y;
            return e * e + f * f
        },
        _sqClosestPointOnSegment: function(a, c, e, f) {
            var d = c.x;
            c = c.y;
            var g = e.x - d,
                h = e.y - c,
                k = g * g + h * h;
            0 < k && (k = ((a.x - d) * g + (a.y - c) * h) / k, 1 < k ? (d = e.x, c = e.y) : 0 < k && (d += g * k, c += h * k));
            g = a.x - d;
            h = a.y - c;
            return f ? g * g + h * h : new ngr.Point(d, c)
        }
    };
    ///--------------------------------Polyline -------------------------------------
    ngr.Polyline = ngr.Path.extend({
        initialize: function(a,
                             c) {
            ngr.Path.prototype.initialize.call(this, c);
            this._latlngs = this._convertLatLngs(a)
        },
        options: {
            smoothFactor: 1,
            noClip: !1
        },
        projectLatlngs: function() {
            this._originalPoints = [];
            for (var a = 0, b = this._latlngs.length; a < b; a++) this._originalPoints[a] = this._map.latLngToLayerPoint(this._latlngs[a])
        },
        getPathString: function() {
            for (var a = 0, b = this._parts.length, e = ""; a < b; a++) e += this._getPathPartStr(this._parts[a]);
            return e
        },
        getLatLngs: function() {
            return this._latlngs
        },
        setLatLngs: function(a) {
            this._latlngs = this._convertLatLngs(a);
            return this.redraw()
        },
        addLatLng: function(a) {
            this._latlngs.push(ngr.latLng(a));
            return this.redraw()
        },
        spliceLatLngs: function() {
            var a = [].splice.apply(this._latlngs, arguments);
            this._convertLatLngs(this._latlngs, !0);
            this.redraw();
            return a
        },
        closestLayerPoint: function(a) {
            for (var c = Infinity, e = this._parts, f, d, g = null, h = 0, k = e.length; h < k; h++)
                for (var n = e[h], q = 1, t = n.length; q < t; q++) {
                    f = n[q - 1];
                    d = n[q];
                    var y = ngr.LineUtil._sqClosestPointOnSegment(a, f, d, !0);
                    y < c && (c = y, g = ngr.LineUtil._sqClosestPointOnSegment(a, f, d))
                }
            g && (g.distance =
                Math.sqrt(c));
            return g
        },
        getBounds: function() {
            return new ngr.LatLngBounds(this.getLatLngs())
        },
        _convertLatLngs: function(a, c) {
            var i, f, d = c ? a : [];
            i = 0;
            for (f = a.length; i < f; i++) {
                if (ngr.Util.isArray(a[i]) && "number" !== typeof a[i][0]) return;
                d[i] = ngr.latLng(a[i])
            }
            return d
        },
        _initEvents: function() {
            ngr.Path.prototype._initEvents.call(this)
        },
        _getPathPartStr: function(a) {
            for (var c = ngr.Path.VML, e = 0, f = a.length, d = "", g; e < f; e++) g = a[e], c && g._round(), d += (e ? "L" : "M") + g.x + " " + g.y;
            return d
        },
        _clipPoints: function() {
            var a = this._originalPoints,
                c = a.length,
                e, f, d;
            if (this.options.noClip) this._parts = [a];
            else {
                var g = this._parts = [],
                    h = this._map._pathViewport,
                    k = ngr.LineUtil;
                for (f = e = 0; e < c - 1; e++)
                    if (d = k.clipSegment(a[e], a[e + 1], h, e))
                        if (g[f] = g[f] || [], g[f].push(d[0]), d[1] !== a[e + 1] || e === c - 2) g[f].push(d[1]), f++
            }
        },
        _simplifyPoints: function() {
            for (var a = this._parts, c = ngr.LineUtil, e = 0, f = a.length; e < f; e++) a[e] = c.simplify(a[e], this.options.smoothFactor)
        },
        _updatePath: function() {
            this._map && (this._clipPoints(), this._simplifyPoints(), ngr.Path.prototype._updatePath.call(this))
        }
    });
    ngr.polyline = function(a, c) {
        return new ngr.Polyline(a, c)
    };
    ngr.PolyUtil = {};
    ngr.PolyUtil.clipPolygon = function(a, c) {
        var e, f = [1, 4, 2, 8],
            d, g, h, k, n, q, t = ngr.LineUtil;
        d = 0;
        for (n = a.length; d < n; d++) a[d]._code = t._getBitCode(a[d], c);
        for (h = 0; 4 > h; h++) {
            q = f[h];
            e = [];
            d = 0;
            n = a.length;
            for (g = n - 1; d < n; g = d++)(k = a[d], g = a[g], k._code & q) ? g._code & q || (g = t._getEdgeIntersection(g, k, q, c), g._code = t._getBitCode(g, c), e.push(g)) : (g._code & q && (g = t._getEdgeIntersection(g, k, q, c), g._code = t._getBitCode(g, c), e.push(g)), e.push(k));
            a = e
        }
        return a
    };
    ngr.Polygon =
        ngr.Polyline.extend({
            options: {
                fill: !0
            },
            initialize: function(a, c) {
                ngr.Polyline.prototype.initialize.call(this, a, c);
                this._initWithHoles(a);
                this._innerPointCache = {};
                this._zoomSizeCache = {}
            },
            _initWithHoles: function(a) {
                var c, e;
                if (a && ngr.Util.isArray(a[0]) && "number" !== typeof a[0][0])
                    for (this._latlngs = this._convertLatLngs(a[0]), this._holes = a.slice(1), a = 0, c = this._holes.length; a < c; a++) e = this._holes[a] = this._convertLatLngs(this._holes[a]), e[0].equals(e[e.length - 1]) && e.pop();
                a = this._latlngs;
                2 <= a.length && a[0].equals(a[a.length -
                1]) && a.pop()
            },
            projectLatlngs: function() {
                ngr.Polyline.prototype.projectLatlngs.call(this);
                this._holePoints = [];
                if (this._holes) {
                    var a, c, e, f;
                    a = 0;
                    for (e = this._holes.length; a < e; a++)
                        for (this._holePoints[a] = [], c = 0, f = this._holes[a].length; c < f; c++) this._holePoints[a][c] = this._map.latLngToLayerPoint(this._holes[a][c])
                }
            },
            setLatLngs: function(a) {
                return a && ngr.Util.isArray(a[0]) && "number" !== typeof a[0][0] ? (this._initWithHoles(a), this.redraw()) : ngr.Polyline.prototype.setLatLngs.call(this, a)
            },
            _clipPoints: function() {
                var a = [];
                this._parts = [this._originalPoints].concat(this._holePoints);
                if (!this.options.noClip) {
                    for (var c = 0, e = this._parts.length; c < e; c++) {
                        var f = ngr.PolyUtil.clipPolygon(this._parts[c], this._map._pathViewport);
                        f.length && a.push(f)
                    }
                    this._parts = a
                }
            },
            _getPathPartStr: function(a) {
                return ngr.Polyline.prototype._getPathPartStr.call(this, a) + (ngr.Browser.svg ? "z" : "x")
            },
            getCentroid: function() {
                if (this._latlngs) {
                    var a = this._latlngs.length;
                    if (0 < a && 2 >= a) return ngr.latLng(this._latlngs[0]);
                    if (2 < a) {
                        var c = 0,
                            e = 0,
                            f = 0,
                            d;
                        d = ngr.CRS.EPSG3857.project(this._latlngs[0]);
                        var g = d.x,
                            h = d.y;
                        for (d = 0; d < a; ++d) var k = ngr.CRS.EPSG3857.project(this._latlngs[d]),
                            n = ngr.CRS.EPSG3857.project(this._latlngs[d === a - 1 ? 0 : d + 1]),
                            f = f + (k.x * n.y - n.x * k.y) / 2;
                        if (0 != f) {
                            for (d = 0; d < a; ++d) var k = ngr.CRS.EPSG3857.project(this._latlngs[d]),
                                n = ngr.CRS.EPSG3857.project(this._latlngs[d === a - 1 ? 0 : d + 1]),
                                q = (k.x - g) * (n.y - h) - (n.x - g) * (k.y - h),
                                c = c + (k.x + n.x - 2 * g) * q,
                                e = e + (k.y + n.y - 2 * h) * q;
                            return ngr.latLng(ngr.CRS.EPSG3857.unproject(ngr.point(g + c / (6 * f), h + e / (6 * f))))
                        }
                        for (d = 0; d < a - 1; ++d) k = ngr.CRS.EPSG3857.project(this._latlngs[d]), c += k.x, e +=
                            k.y;
                        return ngr.latLng(ngr.CRS.EPSG3857.unproject(ngr.point(c / (a - 1), e / (a - 1))))
                    }
                    return null
                }
            },
            _calcMinPSDistance: function(a, c) {
                for (var e = Number.MAX_VALUE, f, d = 0; d < a.length; ++d) f = ngr.Algorithm.pointSegmentDistance(a[d], a[(d + 1) % a.length], c), f < e && (e = f);
                return e
            },
            _calculateInnerPoint: function(a, c) {
                for (var e = a.length, f = a[c], d = a[(c + 1) % e], g = a[(c + e - 1) % e], k = [c, (c + 1) % e, (c + e - 1) % e], l = [], n = 0; n < e; ++n) 0 <= k.indexOf(n) || ngr.Algorithm.pointInTriangle(g, f, d, a[n]) && (l[n] = ngr.Algorithm.pointDistance(f, a[n], !0));
                if (0 === l.length) f = ngr.point((g.x +
                d.x) / 2, (g.y + d.y) / 2);
                else {
                    l.length = e;
                    for (n = 0; n < e; ++n) l[n] === h && (l[n] = Number.MAX_VALUE);
                    e = a[l.indexOf(Math.min.apply(null, l))];
                    f = ngr.point((f.x + e.x) / 2, (f.y + e.y) / 2)
                }
                return [ngr.CRS.EPSG3857.unproject(f), this._calcMinPSDistance(a, f)]
            },
            getInnerPoint: function(a) {
                a || (a = .5);
                if (a + "" in this._innerPointCache) return this._innerPointCache[a + ""];
                for (var c = this._latlngs.length, e = [], f = 0; f < c; ++f) e[f] = ngr.CRS.EPSG3857.project(this._latlngs[f]);
                f = ngr.LineUtil.simplify(e, a);
                if (3 <= f.length) {
                    for (var e = f, c = f.length, f = [], d = 0; d < c; ++d) f[d] =
                        ngr.CRS.EPSG3857.unproject(e[d]);
                    this._simplifiedlatlngs = f
                }
                if (3 === c) return this.getCentroid();
                d = {
                    xMin: {
                        index: [0],
                        value: e[0].x
                    },
                    xMax: {
                        index: [0],
                        value: e[0].x
                    },
                    yMin: {
                        index: [0],
                        value: e[0].y
                    },
                    yMax: {
                        index: [0],
                        value: e[0].y
                    }
                };
                for (f = 0; f < c; ++f) e[f].x < d.xMin.value ? d.xMin = {
                    index: [f],
                    value: e[f].x
                } : e[f].x > d.xMax.value ? d.xMax = {
                    index: [f],
                    value: e[f].x
                } : e[f].x == d.xMin.value ? d.xMin.index.push(f) : e[f].x == d.xMax.value && d.xMax.index.push(f), e[f].y <= d.yMin.value ? d.yMin = {
                    index: [f],
                    value: e[f].y
                } : e[f].y >= d.yMax.value ? d.yMax = {
                    index: [f],
                    value: e[f].y
                } : e[f].y == d.yMin.value ? d.yMin.index.push(f) : e[f].y == d.yMax.value && d.yMax.index.push(f);
                var c = [],
                    f = [],
                    g;
                for (g in d) f = f.concat(d[g].index);
                for (; 0 != f.length;) g = f.pop(), -1 == c.indexOf(g) && c.push(g);
                g = null;
                d = Number.MIN_VALUE;
                for (f = 0; f < c.length; ++f) {
                    var h = this._calculateInnerPoint(e, c[f]);
                    h[1] > d && (g = h[0], d = h[1])
                }
                return this._innerPointCache[a + ""] = g
            },
            _getSimplifiedLatlngs: function() {
                return this._simplifiedlatlngs || this._latlngs
            },
            _getSimplifiedPolygon: function(a) {
                return ngr.polygon(this._getSimplifiedLatlngs(),
                    a)
            },
            getSize: function() {
                if (this._map) return 0 == this._originalPoints.length ? null : this._map.getZoom() in this._zoomSizeCache ? this._zoomSizeCache[this._map.getZoom()] : this._zoomSizeCache[this._map.getZoom()] = ngr.bounds.call(null, this._originalPoints).getSize()
            }
        });
    ngr.polygon = function(a, c) {
        return new ngr.Polygon(a, c)
    };
    (function() {
        function a(a) {
            return ngr.FeatureGroup.extend({
                initialize: function(a, b) {
                    this._layers = {};
                    this._options = b;
                    this.setLatLngs(a)
                },
                setLatLngs: function(b) {
                    var d = 0,
                        g = b.length;
                    for (this.eachLayer(function(a) {
                        d <
                        g ? a.setLatLngs(b[d++]) : this.removeLayer(a)
                    }, this); d < g;) this.addLayer(new a(b[d++], this._options));
                    return this
                },
                getLatLngs: function() {
                    var a = [];
                    this.eachLayer(function(b) {
                        a.push(b.getLatLngs())
                    });
                    return a
                }
            })
        }
        ngr.MultiPolyline = a(ngr.Polyline);
        ngr.MultiPolygon = a(ngr.Polygon);
        ngr.multiPolyline = function(a, e) {
            return new ngr.MultiPolyline(a, e)
        };
        ngr.multiPolygon = function(a, e) {
            return new ngr.MultiPolygon(a, e)
        }
    })();
    ngr.Rectangle = ngr.Polygon.extend({
        initialize: function(a, c) {
            ngr.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(a),
                c)
        },
        setBounds: function(a) {
            this.setLatLngs(this._boundsToLatLngs(a))
        },
        _boundsToLatLngs: function(a) {
            a = ngr.latLngBounds(a);
            return [a.getSouthWest(), a.getNorthWest(), a.getNorthEast(), a.getSouthEast()]
        }
    });
    ngr.rectangle = function(a, c) {
        return new ngr.Rectangle(a, c)
    };
    ngr.Circle = ngr.Path.extend({
        initialize: function(a, c, e) {
            ngr.Path.prototype.initialize.call(this, e);
            this._latlng = ngr.latLng(a);
            this._mRadius = c
        },
        options: {
            fill: !0
        },
        setLatLng: function(a) {
            this._latlng = ngr.latLng(a);
            return this.redraw()
        },
        setRadius: function(a) {
            this._mRadius =
                a;
            return this.redraw()
        },
        projectLatlngs: function() {
            var a = this._getLngRadius(),
                b = this._latlng,
                a = this._map.latLngToLayerPoint([b.lat, b.lng - a]);
            this._point = this._map.latLngToLayerPoint(b);
            this._radius = Math.max(this._point.x - a.x, 1)
        },
        getBounds: function() {
            var a = this._getLngRadius(),
                c = this._mRadius / 40075017 * 360,
                e = this._latlng;
            return new ngr.LatLngBounds([e.lat - c, e.lng - a], [e.lat + c, e.lng + a])
        },
        getLatLng: function() {
            return this._latlng
        },
        getPathString: function() {
            var a = this._point,
                c = this._radius;
            if (this._checkIfEmpty()) return "";
            if (ngr.Browser.svg) return "M" + a.x + "," + (a.y - c) + "A" + c + "," + c + ",0,1,1," + (a.x - .1) + "," + (a.y - c) + " z";
            a._round();
            c = Math.round(c);
            return "AL " + a.x + "," + a.y + " " + c + "," + c + " 0,23592600"
        },
        getRadius: function() {
            return this._mRadius
        },
        _getLatRadius: function() {
            return this._mRadius / 40075017 * 360
        },
        _getLngRadius: function() {
            return this._getLatRadius() / Math.cos(ngr.LatLng.DEG_TO_RAD * this._latlng.lat)
        },
        _checkIfEmpty: function() {
            if (!this._map) return !1;
            var a = this._map._pathViewport,
                b = this._radius,
                e = this._point;
            return e.x - b > a.max.x ||
                e.y - b > a.max.y || e.x + b < a.min.x || e.y + b < a.min.y
        }
    });
    ngr.circle = function(a, c, e) {
        return new ngr.Circle(a, c, e)
    };
    ngr.CircleMarker = ngr.Circle.extend({
        options: {
            radius: 10,
            weight: 2
        },
        initialize: function(a, c) {
            ngr.Circle.prototype.initialize.call(this, a, null, c);
            this._radius = this.options.radius
        },
        projectLatlngs: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng)
        },
        _updateStyle: function() {
            ngr.Circle.prototype._updateStyle.call(this);
            this.setRadius(this.options.radius)
        },
        setLatLng: function(a) {
            ngr.Circle.prototype.setLatLng.call(this,
                a);
            this._popup && this._popup._isOpen && this._popup.setLatLng(a);
            return this
        },
        setRadius: function(a) {
            this.options.radius = this._radius = a;
            return this.redraw()
        },
        getRadius: function() {
            return this._radius
        }
    });
    ngr.circleMarker = function(a, c) {
        return new ngr.CircleMarker(a, c)
    };
    ngr.Polyline.include(ngr.Path.CANVAS ? {
        _containsPoint: function(a, c) {
            var e, d, g, h, k, l, n = this.options.weight / 2;
            ngr.Browser.touch && (n += 10);
            e = 0;
            for (h = this._parts.length; e < h; e++)
                for (l = this._parts[e], d = 0, k = l.length, g = k - 1; d < k; g = d++)
                    if (c || 0 !== d)
                        if (g = ngr.LineUtil.pointToSegmentDistance(a,
                                l[g], l[d]), g <= n) return !0;
            return !1
        }
    } : {});
    ngr.Polygon.include(ngr.Path.CANVAS ? {
        _containsPoint: function(a) {
            var c = !1,
                e, d, g, h, k, l, n;
            if (ngr.Polyline.prototype._containsPoint.call(this, a, !0)) return !0;
            h = 0;
            for (l = this._parts.length; h < l; h++)
                for (e = this._parts[h], k = 0, n = e.length, g = n - 1; k < n; g = k++) d = e[k], g = e[g], d.y > a.y !== g.y > a.y && a.x < (g.x - d.x) * (a.y - d.y) / (g.y - d.y) + d.x && (c = !c);
            return c
        },
        _updateStyle: function() {
            this._updateStrokeStyle();
            this._updateFillStyle()
        },
        _updateStrokeStyle: function() {
            var a = this.options;
            a.stroke && (this._ctx.lineWidth =
                a.weight, this._ctx.strokeStyle = a.color)
        },
        _updateFillStyle: function() {
            var a = this.options;
            if (a.texture) {
                var b = this._map.latLngToLayerPoint(this._map._fixedPointOnMap);
                this._ctx.translate(b.x, b.y);
                if (!this._pattern)
                    if (a.texture in NGR.Cache._patternCache) this._pattern = NGR.Cache._patternCache[a.texture];
                    else if (a.texture in NGR.Cache._imageCache) this._pattern = this._map._canvasCtx.createPattern(this.preparePattern(a.texture), "repeat"), NGR.Cache._patternCache[a.texture] = this._pattern;
                    else {
                        this._ctx.fillStyle =
                            a.fillColor || a.color;
                        return
                    }
                b = Math.pow(2, this._map.zoomDelta);
                this._ctx.scale(b, b);
                a.textureRotate && this._ctx.rotate(a.textureRotate);
                this._ctx.fillStyle = this._pattern
            } else a.fill && (this._ctx.fillStyle = a.fillColor || a.color)
        },
        _updatePath: function() {
            if (this._map && (this._clipPoints(), this._simplifyPoints(), !this._checkIfEmpty())) {
                var a = this._ctx,
                    b = this.options;
                this._drawPath();
                a.save();
                this._updateFillStyle();
                b.fill && (a.globalAlpha = b.fillOpacity, a.fill());
                a.restore();
                a.save();
                this._updateStrokeStyle();
                b.stroke && (a.globalAlpha = b.opacity, a.stroke());
                a.restore()
            }
        },
        preparePattern: function(a) {
            var c = this,
                e = this.options,
                d = function(a) {
                    var b = /^(\d+|\d*\.\d+)\s*(m|px)?$/i.exec(a);
                    if (3 !== b.length) console.error('Wrong syntax "' + a + '" in fixedSize.');
                    else return {
                        value: parseFloat(b[1]),
                        unit: b[2] ? b[2] : "px"
                    }
                };
            return function(b) {
                if (a in NGR.Cache._imageCache) {
                    var c = g.createElement("canvas");
                    c.width = b.x;
                    c.height = b.y;
                    c.getContext("2d").drawImage(NGR.Cache._imageCache[a], 0, 0, b.x, b.y);
                    return c
                }
            }(function(a, e) {
                var d,
                    f, g = ngr.point(0, 0);
                switch (a.unit + " " + e.unit) {
                    case "m m":
                        d = c._map.latLngToContainerPoint(c._map._fixedPointOnMap);
                        f = c._map.latLngToContainerPoint(c._map._fixedPointOnMapOffsetOneMeter);
                        d = Math.abs(d.x - f.x);
                        g.x = d * a.value;
                        g.y = d * e.value;
                        break;
                    case "px px":
                        g.x = a.value;
                        g.y = a.value;
                        break;
                    default:
                        return console.warn("Unsupported unit combination", a.unit + "+" + e.unit), null
                }
                return g
            }(d(e.textureSize[0]), d(e.textureSize[1])))
        }
    } : {});
    ngr.Circle.include(ngr.Path.CANVAS ? {
        _drawPath: function() {
            var a = this._point;
            this._ctx.beginPath();
            this._ctx.arc(a.x, a.y, this._radius, 0, 2 * Math.PI, !1)
        },
        _containsPoint: function(a) {
            var b = this.options.stroke ? this.options.weight / 2 : 0;
            return a.distanceTo(this._point) <= this._radius + b
        }
    } : {});
    ngr.CircleMarker.include(ngr.Path.CANVAS ? {
        _updateStyle: function() {
            ngr.Path.prototype._updateStyle.call(this)
        }
    } : {});
    ngr.GeoJSON = ngr.FeatureGroup.extend({
        initialize: function(a, c) {
            ngr.setOptions(this, c);
            this._layers = {};
            a && this.addData(a)
        },
        addData: function(a) {
            var c = ngr.Util.isArray(a) ? a : a.features,
                e, d;
            if (c) {
                a = 0;
                for (e = c.length; a < e; a++) d =
                    c[a], (d.geometries || d.geometry || d.features || d.coordinates) && this.addData(c[a]);
                return this
            }
            c = this.options;
            if (!c.filter || c.filter(a)) {
                e = ngr.GeoJSON.geometryToLayer(a, c.pointToLayer, c.coordsToLatLng, c);
                e.feature = ngr.GeoJSON.asFeature(a);
                e.defaultOptions = e.options;
                this.resetStyle(e);
                if (c.onEachFeature) c.onEachFeature(a, e);
                return this.addLayer(e)
            }
        },
        resetStyle: function(a) {
            var c = this.options.style;
            c && (ngr.Util.extend(a.options, a.defaultOptions), this._setLayerStyle(a, c))
        },
        setStyle: function(a) {
            this.eachLayer(function(b) {
                this._setLayerStyle(b,
                    a)
            }, this)
        },
        _setLayerStyle: function(a, b) {
            "function" === typeof b && (b = b(a.feature));
            a.setStyle && a.setStyle(b)
        }
    });
    ngr.extend(ngr.GeoJSON, {
        geometryToLayer: function(a, c, e, d) {
            var g = "Feature" === a.type ? a.geometry : a,
                h = g.coordinates,
                k = [],
                l, n;
            e = e || this.coordsToLatLng;
            switch (g.type) {
                case "Point":
                    return d = e(h), c ? c(a, d) : new ngr.Marker(d);
                case "MultiPoint":
                    l = 0;
                    for (n = h.length; l < n; l++) d = e(h[l]), k.push(c ? c(a, d) : new ngr.Marker(d));
                    return new ngr.FeatureGroup(k);
                case "LineString":
                    return a = this.coordsToLatLngs(h, 0, e), new ngr.Polyline(a,
                        d);
                case "Polygon":
                    if (2 === h.length && !h[1].length) throw Error("Invalid GeoJSON object.");
                    a = this.coordsToLatLngs(h, 1, e);
                    return new ngr.Polygon(a, d);
                case "MultiLineString":
                    return a = this.coordsToLatLngs(h, 1, e), new ngr.MultiPolyline(a, d);
                case "MultiPolygon":
                    return a = this.coordsToLatLngs(h, 2, e), new ngr.MultiPolygon(a, d);
                case "GeometryCollection":
                    l = 0;
                    for (n = g.geometries.length; l < n; l++) k.push(this.geometryToLayer({
                        geometry: g.geometries[l],
                        type: "Feature",
                        properties: a.properties
                    }, c, e, d));
                    return new ngr.FeatureGroup(k);
                default:
                    throw Error("Invalid GeoJSON object.");
            }
        },
        coordsToLatLng: function(a) {
            return new ngr.LatLng(a[1], a[0], a[2])
        },
        coordsToLatLngs: function(a, b, e) {
            var d, g, h, k = [];
            g = 0;
            for (h = a.length; g < h; g++) d = b ? this.coordsToLatLngs(a[g], b - 1, e) : (e || this.coordsToLatLng)(a[g]), k.push(d);
            return k
        },
        latLngToCoords: function(a) {
            var b = [a.lng, a.lat];
            a.alt !== h && b.push(a.alt);
            return b
        },
        latLngsToCoords: function(a) {
            for (var c = [], e = 0, d = a.length; e < d; e++) c.push(ngr.GeoJSON.latLngToCoords(a[e]));
            return c
        },
        getFeature: function(a, c) {
            return a.feature ?
                ngr.extend({}, a.feature, {
                    geometry: c
                }) : ngr.GeoJSON.asFeature(c)
        },
        asFeature: function(a) {
            return "Feature" === a.type ? a : {
                type: "Feature",
                properties: {},
                geometry: a
            }
        }
    });
    var l = {
        toGeoJSON: function() {
            return ngr.GeoJSON.getFeature(this, {
                type: "Point",
                coordinates: ngr.GeoJSON.latLngToCoords(this.getLatLng())
            })
        }
    };
    ngr.Marker.include(l);
    ngr.Circle.include(l);
    ngr.CircleMarker.include(l);
    ngr.Polyline.include({
        toGeoJSON: function() {
            return ngr.GeoJSON.getFeature(this, {
                type: "LineString",
                coordinates: ngr.GeoJSON.latLngsToCoords(this.getLatLngs())
            })
        }
    });
    ngr.Polygon.include({
        toGeoJSON: function() {
            var a = [ngr.GeoJSON.latLngsToCoords(this.getLatLngs())],
                c, e, d;
            a[0].push(a[0][0]);
            if (this._holes)
                for (c = 0, e = this._holes.length; c < e; c++) d = ngr.GeoJSON.latLngsToCoords(this._holes[c]), d.push(d[0]), a.push(d);
            return ngr.GeoJSON.getFeature(this, {
                type: "Polygon",
                coordinates: a
            })
        }
    });
    (function() {
        function a(a) {
            return function() {
                var e = [];
                this.eachLayer(function(a) {
                    e.push(a.toGeoJSON().geometry.coordinates)
                });
                return ngr.GeoJSON.getFeature(this, {
                    type: a,
                    coordinates: e
                })
            }
        }
        ngr.MultiPolyline.include({
            toGeoJSON: a("MultiLineString")
        });
        ngr.MultiPolygon.include({
            toGeoJSON: a("MultiPolygon")
        });
        ngr.LayerGroup.include({
            toGeoJSON: function() {
                var c = this.feature && this.feature.geometry,
                    e = [],
                    d;
                if (c && "MultiPoint" === c.type) return a("MultiPoint").call(this);
                var g = c && "GeometryCollection" === c.type;
                this.eachLayer(function(a) {
                    a.toGeoJSON && (d = a.toGeoJSON(), e.push(g ? d.geometry : ngr.GeoJSON.asFeature(d)))
                });
                return g ? ngr.GeoJSON.getFeature(this, {
                    geometries: e,
                    type: "GeometryCollection"
                }) : {
                    type: "FeatureCollection",
                    features: e
                }
            }
        })
    })();
    ngr.geoJson = function(a, c) {
        return new ngr.GeoJSON(a,
            c)
    };
    ngr.DomEvent = {
        addListener: function(a, c, e, d) {
            var g = ngr.stamp(e),
                h = "_ngr_" + c + g,
                k, l;
            if (a[h]) return this;
            k = function(c) {
                return e.call(d || a, c || ngr.DomEvent._getEvent())
            };
            if (ngr.Browser.pointer && 0 === c.indexOf("touch")) return this.addPointerListener(a, c, k, g);
            ngr.Browser.touch && "dblclick" === c && this.addDoubleTapListener && this.addDoubleTapListener(a, k, g);
            "addEventListener" in a ? "mousewheel" === c ? (a.addEventListener("DOMMouseScroll", k, !1), a.addEventListener(c, k, !1)) : "mouseenter" === c || "mouseleave" === c ? (l = k, k = function(c) {
                if (ngr.DomEvent._checkMouse(a,
                        c)) return l(c)
            }, a.addEventListener("mouseenter" === c ? "mouseover" : "mouseout", k, !1)) : ("click" === c && ngr.Browser.android && (l = k, k = function(a) {
                return ngr.DomEvent._filterClick(a, l)
            }), a.addEventListener(c, k, !1)) : "attachEvent" in a && a.attachEvent("on" + c, k);
            a[h] = k;
            return this
        },
        removeListener: function(a, c, e) {
            e = ngr.stamp(e);
            var d = "_ngr_" + c + e,
                g = a[d];
            if (!g) return this;
            ngr.Browser.pointer && 0 === c.indexOf("touch") ? this.removePointerListener(a, c, e) : ngr.Browser.touch && "dblclick" === c && this.removeDoubleTapListener ? this.removeDoubleTapListener(a,
                e) : "removeEventListener" in a ? "mousewheel" === c ? (a.removeEventListener("DOMMouseScroll", g, !1), a.removeEventListener(c, g, !1)) : "mouseenter" === c || "mouseleave" === c ? a.removeEventListener("mouseenter" === c ? "mouseover" : "mouseout", g, !1) : a.removeEventListener(c, g, !1) : "detachEvent" in a && a.detachEvent("on" + c, g);
            a[d] = null;
            return this
        },
        stopPropagation: function(a) {
            a.stopPropagation ? a.stopPropagation() : a.cancelBubble = !0;
            ngr.DomEvent._skipped(a);
            return this
        },
        disableScrollPropagation: function(a) {
            var c = ngr.DomEvent.stopPropagation;
            return ngr.DomEvent.on(a, "mousewheel", c).on(a, "MozMousePixelScroll", c)
        },
        disableClickPropagation: function(a) {
            for (var c = ngr.DomEvent.stopPropagation, e = ngr.Draggable.START.length - 1; 0 <= e; e--) ngr.DomEvent.on(a, ngr.Draggable.START[e], c);
            return ngr.DomEvent.on(a, "click", ngr.DomEvent._fakeStop).on(a, "dblclick", c)
        },
        preventDefault: function(a) {
            a.preventDefault ? a.preventDefault() : a.returnValue = !1;
            return this
        },
        stop: function(a) {
            return ngr.DomEvent.preventDefault(a).stopPropagation(a)
        },
        getMousePosition: function(a, c) {
            if (!c) return new ngr.Point(a.clientX,
                a.clientY);
            var e = c.getBoundingClientRect();
            return new ngr.Point(a.clientX - e.left - c.clientLeft, a.clientY - e.top - c.clientTop)
        },
        getWheelDelta: function(a) {
            var b = 0;
            a.wheelDelta && (b = a.wheelDelta / 120);
            a.detail && (b = -a.detail / 3);
            return b
        },
        _skipEvents: {},
        _fakeStop: function(a) {
            ngr.DomEvent._skipEvents[a.type] = !0
        },
        _skipped: function(a) {
            var b = this._skipEvents[a.type];
            this._skipEvents[a.type] = !1;
            return b
        },
        _checkMouse: function(a, b) {
            var e = b.relatedTarget;
            if (!e) return !0;
            try {
                for (; e && e !== a;) e = e.parentNode
            } catch (d) {
                return !1
            }
            return e !==
                a
        },
        _getEvent: function() {
            var a = d.event;
            if (!a)
                for (var b = arguments.callee.caller; b && (!(a = b.arguments[0]) || d.Event !== a.constructor);) b = b.caller;
            return a
        },
        _filterClick: function(a, c) {
            var e = a.timeStamp || a.originalEvent.timeStamp,
                d = ngr.DomEvent._lastClick && e - ngr.DomEvent._lastClick;
            if (d && 100 < d && 500 > d || a.target._simulatedClick && !a._simulated) ngr.DomEvent.stop(a);
            else return ngr.DomEvent._lastClick = e, c(a)
        }
    };
    ngr.DomEvent.on = ngr.DomEvent.addListener;
    ngr.DomEvent.off = ngr.DomEvent.removeListener;
    ngr.Draggable = ngr.Class.extend({
        includes: ngr.Mixin.Events,
        statics: {
            START: ngr.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
            END: {
                mousedown: "mouseup",
                touchstart: "touchend",
                pointerdown: "touchend",
                MSPointerDown: "touchend"
            },
            MOVE: {
                mousedown: "mousemove",
                touchstart: "touchmove",
                pointerdown: "touchmove",
                MSPointerDown: "touchmove"
            }
        },
        initialize: function(a, b) {
            this._element = a;
            this._dragStartTarget = b || a
        },
        enable: function() {
            if (!this._enabled) {
                for (var a = ngr.Draggable.START.length - 1; 0 <= a; a--) ngr.DomEvent.on(this._dragStartTarget, ngr.Draggable.START[a], this._onDown, this);
                this._enabled = !0
            }
        },
        disable: function() {
            if (this._enabled) {
                for (var a = ngr.Draggable.START.length - 1; 0 <= a; a--) ngr.DomEvent.off(this._dragStartTarget, ngr.Draggable.START[a], this._onDown, this);
                this._moved = this._enabled = !1
            }
        },
        _onDown: function(a) {
            this._moved = !1;
            if (!(a.shiftKey || 1 !== a.which && 1 !== a.button && !a.touches || (ngr.DomEvent.stopPropagation(a), ngr.Draggable._disabled || (ngr.DomUtil.disableImageDrag(), ngr.DomUtil.disableTextSelection(), this._moving)))) {
                var c = a.touches ? a.touches[0] : a;
                this._startPoint = new ngr.Point(c.clientX, c.clientY);
                this._startPos = this._newPos = ngr.DomUtil.getPosition(this._element);
                ngr.DomEvent.on(g, ngr.Draggable.MOVE[a.type], this._onMove, this).on(g, ngr.Draggable.END[a.type], this._onUp, this)
            }
        },
        _onMove: function(a) {
            if (a.touches && 1 < a.touches.length) this._moved = !0;
            else {
                var c = a.touches && 1 === a.touches.length ? a.touches[0] : a,
                    vec = (new ngr.Point(c.clientX, c.clientY)).subtract(this._startPoint);
                !vec.x && !vec.y || ngr.Browser.touch && 3 > Math.abs(vec.x) + Math.abs(vec.y) || (ngr.DomEvent.preventDefault(a), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = ngr.DomUtil.getPosition(this._element).subtract(vec), ngr.DomUtil.addClass(g.body, "ngr-dragging"), this._lastTarget = a.target || a.srcElement, ngr.DomUtil.addClass(this._lastTarget, "ngr-drag-target")), this._newPos = this._startPos.add(vec), this._moving = !0, ngr.Util.cancelAnimFrame(this._animRequest), this._animRequest = ngr.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget))
            }
        },
        _updatePosition: function() {
            this.fire("predrag");
            ngr.DomUtil.setPosition(this._element, this._newPos);
            this.fire("drag")
        },
        _onUp: function() {
            ngr.DomUtil.removeClass(g.body, "ngr-dragging");
            this._lastTarget && (ngr.DomUtil.removeClass(this._lastTarget, "ngr-drag-target"), this._lastTarget = null);
            for (var a in ngr.Draggable.MOVE) ngr.DomEvent.off(g, ngr.Draggable.MOVE[a], this._onMove).off(g, ngr.Draggable.END[a], this._onUp);
            ngr.DomUtil.enableImageDrag();
            ngr.DomUtil.enableTextSelection();
            this._moved && this._moving && (ngr.Util.cancelAnimFrame(this._animRequest), this.fire("dragend", {
                distance: this._newPos.distanceTo(this._startPos)
            }));
            this._moving = !1
        }
    });
    ngr.Handler = ngr.Class.extend({
        initialize: function(a) {
            this._map = a
        },
        enable: function() {
            this._enabled || (this._enabled = !0, this.addHooks())
        },
        disable: function() {
            this._enabled && (this._enabled = !1, this.removeHooks())
        },
        enabled: function() {
            return !!this._enabled
        }
    });
    ngr.Map.mergeOptions({
        dragging: !0,
        inertia: !ngr.Browser.android23,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: Infinity,
        inertiaThreshold: ngr.Browser.touch ? 32 : 18,
        easeLinearity: .25,
        worldCopyJump: !1
    });
    ngr.Map.Drag = ngr.Handler.extend({
        addHooks: function() {
            if (!this._draggable) {
                var a =
                    this._map;
                this._draggable = new ngr.Draggable(a._mapPane, a._container);
                this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this);
                a.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), a.on("viewreset", this._onViewReset, this), a.whenReady(this._onViewReset, this))
            }
            this._draggable.enable()
        },
        removeHooks: function() {
            this._draggable.disable()
        },
        moved: function() {
            return this._draggable && this._draggable._moved
        },
        _onDragStart: function() {
            var a = this._map;
            a._panAnim &&
            a._panAnim.stop();
            a.fire("movestart").fire("dragstart");
            a.options.inertia && (this._positions = [], this._times = [])
        },
        _onDrag: function() {
            if (this._map.options.inertia) {
                var a = this._lastTime = +new Date,
                    c = this._lastPos = this._draggable._newPos;
                this._positions.push(c);
                this._times.push(a);
                200 < a - this._times[0] && (this._positions.shift(), this._times.shift());
                ngr.Browser.mobile && 0 < Object.keys(NGR.Cache._imageCache).length && this._map._delayId && (clearTimeout(this._map._delayId), this._map._delayId = null)
            }
            this._map.fire("move").fire("drag")
        },
        _onViewReset: function() {
            var a = this._map.getSize()._divideBy(2);
            this._initialWorldOffset = this._map.latLngToLayerPoint([0, 0]).subtract(a).x;
            this._worldWidth = this._map.project([0, 180]).x
        },
        _onPreDrag: function() {
            var a = this._worldWidth,
                b = Math.round(a / 2),
                e = this._initialWorldOffset,
                d = this._draggable._newPos.x,
                g = (d - b + e) % a + b - e,
                a = (d + b + e) % a - b - e,
                e = Math.abs(g + e) < Math.abs(a + e) ? g : a;
            this._draggable._newPos.x = e
        },
        _onDragEnd: function(a) {
            var c = this._map,
                e = c.options,
                d = +new Date - this._lastTime,
                g = !e.inertia || d > e.inertiaThreshold ||
                    !this._positions[0];
            c.fire("dragend", a);
            if (g) ngr.Browser.mobile && 0 < Object.keys(NGR.Cache._imageCache).length ? c._delayId || (c._delayId = setTimeout(function() {
                c._delayId = null;
                c.fire("moveend")
            }.bind(this), 500)) : c.fire("moveend");
            else {
                a = this._lastPos.subtract(this._positions[0]);
                var h = e.easeLinearity;
                a = a.multiplyBy(h / ((this._lastTime + d - this._times[0]) / 1E3));
                g = a.distanceTo([0, 0]);
                d = Math.min(e.inertiaMaxSpeed, g);
                a = a.multiplyBy(d / g);
                var k = d / (e.inertiaDeceleration * h),
                    l = a.multiplyBy(-k / 2).round();
                l.x && l.y ? (l =
                    c._limitOffset(l, c.options.maxBounds), ngr.Util.requestAnimFrame(function() {
                    c.panBy(l, {
                        duration: k,
                        easeLinearity: h,
                        noMoveStart: !0
                    })
                })) : ngr.Browser.mobile && 0 < Object.keys(NGR.Cache._imageCache).length ? c._delayId || (c._delayId = setTimeout(function() {
                    c._delayId = null;
                    c.fire("moveend")
                }.bind(this), 500)) : c.fire("moveend")
            }
        }
    });
    ngr.Map.addInitHook("addHandler", "dragging", ngr.Map.Drag);
    ngr.Map.mergeOptions({
        doubleClickZoom: !0
    });
    ngr.Map.DoubleClickZoom = ngr.Handler.extend({
        addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick,
                this)
        },
        removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this)
        },
        _onDoubleClick: function(a) {
            var b = this._map,
                e = b.getZoom() + (a.originalEvent.shiftKey ? -1 : 1);
            "center" === b.options.doubleClickZoom ? b.setZoom(e) : b.setZoomAround(a.containerPoint, e)
        }
    });
    ngr.Map.addInitHook("addHandler", "doubleClickZoom", ngr.Map.DoubleClickZoom);
    ngr.Map.mergeOptions({
        scrollWheelZoom: !0
    });
    ngr.Map.ScrollWheelZoom = ngr.Handler.extend({
        addHooks: function() {
            ngr.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll,
                this);
            ngr.DomEvent.on(this._map._container, "MozMousePixelScroll", ngr.DomEvent.preventDefault);
            this._delta = 0
        },
        removeHooks: function() {
            ngr.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll);
            ngr.DomEvent.off(this._map._container, "MozMousePixelScroll", ngr.DomEvent.preventDefault)
        },
        _onWheelScroll: function(a) {
            var c = ngr.DomEvent.getWheelDelta(a);
            this._delta += c;
            this._lastMousePos = this._map.mouseEventToContainerPoint(a);
            this._startTime || (this._startTime = +new Date);
            c = Math.max(40 - (+new Date - this._startTime),
                0);
            clearTimeout(this._timer);
            this._timer = setTimeout(ngr.bind(this._performZoom, this), c);
            ngr.DomEvent.preventDefault(a);
            ngr.DomEvent.stopPropagation(a)
        },
        _performZoom: function() {
            var a = this._map,
                b = this._delta,
                e = a.getZoom(),
                b = 0 < b ? Math.ceil(b) : Math.floor(b),
                b = Math.max(Math.min(b, 4), -4),
                b = a._limitZoom(e + b) - e;
            this._delta = 0;
            this._startTime = null;
            b && ("center" === a.options.scrollWheelZoom ? a.setZoom(e + b) : a.setZoomAround(this._lastMousePos, e + b))
        }
    });
    ngr.Map.addInitHook("addHandler", "scrollWheelZoom", ngr.Map.ScrollWheelZoom);
    ngr.extend(ngr.DomEvent, {
        _touchstart: ngr.Browser.msPointer ? "MSPointerDown" : ngr.Browser.pointer ? "pointerdown" : "touchstart",
        _touchend: ngr.Browser.msPointer ? "MSPointerUp" : ngr.Browser.pointer ? "pointerup" : "touchend",
        addDoubleTapListener: function(a, c, e) {
            function d(a) {
                var c;
                ngr.Browser.pointer ? (t.push(a.pointerId), c = t.length) : c = a.touches.length;
                if (!(1 < c)) {
                    c = Date.now();
                    var e = c - (k || c);
                    r = a.touches ? a.touches[0] : a;
                    l = 0 < e && 250 >= e;
                    k = c
                }
            }

            function h(a) {
                if (ngr.Browser.pointer) {
                    a = t.indexOf(a.pointerId);
                    if (-1 === a) return;
                    t.splice(a, 1)
                }
                if (l) {
                    if (ngr.Browser.pointer) {
                        a = {};
                        var e, d;
                        for (d in r) e = r[d], a[d] = "function" === typeof e ? e.bind(r) : e;
                        r = a
                    }
                    r.type = "dblclick";
                    c(r);
                    k = null
                }
            }
            var k, l = !1,
                r, n = this._touchstart,
                q = this._touchend,
                t = [];
            a["_ngr_" + n + e] = d;
            a["_ngr_" + q + e] = h;
            e = ngr.Browser.pointer ? g.documentElement : a;
            a.addEventListener(n, d, !1);
            e.addEventListener(q, h, !1);
            ngr.Browser.pointer && e.addEventListener(ngr.DomEvent.POINTER_CANCEL, h, !1);
            return this
        },
        removeDoubleTapListener: function(a, c) {
            a.removeEventListener(this._touchstart, a["_ngr_" + this._touchstart + c], !1);
            (ngr.Browser.pointer ? g.documentElement :
                a).removeEventListener(this._touchend, a["_ngr_" + this._touchend + c], !1);
            ngr.Browser.pointer && g.documentElement.removeEventListener(ngr.DomEvent.POINTER_CANCEL, a["_ngr_" + this._touchend + c], !1);
            return this
        }
    });
    ngr.extend(ngr.DomEvent, {
        POINTER_DOWN: ngr.Browser.msPointer ? "MSPointerDown" : "pointerdown",
        POINTER_MOVE: ngr.Browser.msPointer ? "MSPointerMove" : "pointermove",
        POINTER_UP: ngr.Browser.msPointer ? "MSPointerUp" : "pointerup",
        POINTER_CANCEL: ngr.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
        _pointers: [],
        _pointerDocumentListener: !1,
        addPointerListener: function(a, b, e, d) {
            switch (b) {
                case "touchstart":
                    return this.addPointerListenerStart(a, b, e, d);
                case "touchend":
                    return this.addPointerListenerEnd(a, b, e, d);
                case "touchmove":
                    return this.addPointerListenerMove(a, b, e, d);
                default:
                    throw "Unknown touch event type";
            }
        },
        addPointerListenerStart: function(a, c, e, d) {
            var h = this._pointers;
            c = function(a) {
                ngr.DomEvent.preventDefault(a);
                for (var c = !1, d = 0; d < h.length; d++)
                    if (h[d].pointerId === a.pointerId) {
                        c = !0;
                        break
                    }
                c || h.push(a);
                a.touches = h.slice();
                a.changedTouches = [a];
                e(a)
            };
            a["_ngr_touchstart" + d] = c;
            a.addEventListener(this.POINTER_DOWN, c, !1);
            this._pointerDocumentListener || (a = function(a) {
                for (var b = 0; b < h.length; b++)
                    if (h[b].pointerId === a.pointerId) {
                        h.splice(b, 1);
                        break
                    }
            }, g.documentElement.addEventListener(this.POINTER_UP, a, !1), g.documentElement.addEventListener(this.POINTER_CANCEL, a, !1), this._pointerDocumentListener = !0);
            return this
        },
        addPointerListenerMove: function(a, b, e, d) {
            function g(a) {
                if (a.pointerType !== a.MSPOINTER_TYPE_MOUSE && "mouse" !== a.pointerType || 0 !== a.buttons) {
                    for (var b =
                        0; b < h.length; b++)
                        if (h[b].pointerId === a.pointerId) {
                            h[b] = a;
                            break
                        }
                    a.touches = h.slice();
                    a.changedTouches = [a];
                    e(a)
                }
            }
            var h = this._pointers;
            a["_ngr_touchmove" + d] = g;
            a.addEventListener(this.POINTER_MOVE, g, !1);
            return this
        },
        addPointerListenerEnd: function(a, b, e, d) {
            var g = this._pointers;
            b = function(a) {
                for (var b = 0; b < g.length; b++)
                    if (g[b].pointerId === a.pointerId) {
                        g.splice(b, 1);
                        break
                    }
                a.touches = g.slice();
                a.changedTouches = [a];
                e(a)
            };
            a["_ngr_touchend" + d] = b;
            a.addEventListener(this.POINTER_UP, b, !1);
            a.addEventListener(this.POINTER_CANCEL,
                b, !1);
            return this
        },
        removePointerListener: function(a, b, e) {
            e = a["_ngr_" + b + e];
            switch (b) {
                case "touchstart":
                    a.removeEventListener(this.POINTER_DOWN, e, !1);
                    break;
                case "touchmove":
                    a.removeEventListener(this.POINTER_MOVE, e, !1);
                    break;
                case "touchend":
                    a.removeEventListener(this.POINTER_UP, e, !1), a.removeEventListener(this.POINTER_CANCEL, e, !1)
            }
            return this
        }
    });
    ngr.Map.mergeOptions({
        touchZoom: ngr.Browser.touch && !ngr.Browser.android23,
        bounceAtZoomLimits: !0
    });
    ngr.Map.TouchZoom = ngr.Handler.extend({
        addHooks: function() {
            ngr.DomEvent.on(this._map._container,
                "touchstart", this._onTouchStart, this)
        },
        removeHooks: function() {
            ngr.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
        },
        _onTouchStart: function(a) {
            var c = this._map;
            if (a.touches && 2 === a.touches.length && !c._animatingZoom && !this._zooming) {
                var e = c.mouseEventToLayerPoint(a.touches[0]),
                    d = c.mouseEventToLayerPoint(a.touches[1]),
                    h = c._getCenterLayerPoint();
                this._startCenter = e.add(d)._divideBy(2);
                this._startDist = e.distanceTo(d);
                this._moved = !1;
                this._zooming = !0;
                this._centerOffset = h.subtract(this._startCenter);
                c._panAnim && c._panAnim.stop();
                ngr.DomEvent.on(g, "touchmove", this._onTouchMove, this).on(g, "touchend", this._onTouchEnd, this);
                ngr.DomEvent.preventDefault(a)
            }
        },
        _onTouchMove: function(a) {
            var c = this._map;
            if (a.touches && 2 === a.touches.length && this._zooming) {
                var e = c.mouseEventToLayerPoint(a.touches[0]),
                    d = c.mouseEventToLayerPoint(a.touches[1]);
                this._scale = e.distanceTo(d) / this._startDist;
                this._delta = e._add(d)._divideBy(2)._subtract(this._startCenter);
                1 === this._scale || !c.options.bounceAtZoomLimits && (c.getZoom() ===
                c.getMinZoom() && 1 > this._scale || c.getZoom() === c.getMaxZoom() && 1 < this._scale) || (this._moved || (ngr.DomUtil.addClass(c._mapPane, "ngr-touching"), c.fire("movestart").fire("zoomstart"), this._moved = !0), ngr.Util.cancelAnimFrame(this._animRequest), this._animRequest = ngr.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container), ngr.DomEvent.preventDefault(a))
            }
        },
        _updateOnMove: function() {
            var a = this._map,
                b = this._getScaleOrigin(),
                b = a.layerPointToLatLng(b),
                e = a.getScaleZoom(this._scale);
            a._animateZoom(b, e, this._startCenter,
                this._scale, this._delta, !1, !0)
        },
        _onTouchEnd: function() {
            if (this._moved && this._zooming) {
                var a = this._map;
                this._zooming = !1;
                ngr.DomUtil.removeClass(a._mapPane, "ngr-touching");
                ngr.Util.cancelAnimFrame(this._animRequest);
                ngr.DomEvent.off(g, "touchmove", this._onTouchMove).off(g, "touchend", this._onTouchEnd);
                var c = this._getScaleOrigin(),
                    e = a.layerPointToLatLng(c),
                    d = a.getZoom(),
                    h = a.getScaleZoom(this._scale) - d,
                    h = 0 < h ? Math.ceil(h) : Math.floor(h),
                    d = a._limitZoom(d + h),
                    h = a.getZoomScale(d) / this._scale;
                a._animateZoom(e, d, c, h)
            } else this._zooming = !1
        },
        _getScaleOrigin: function() {
            var a = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(a)
        }
    });
    ngr.Map.addInitHook("addHandler", "touchZoom", ngr.Map.TouchZoom);
    ngr.Map.mergeOptions({
        tap: !0,
        tapTolerance: 15
    });
    ngr.Map.Tap = ngr.Handler.extend({
        addHooks: function() {
            ngr.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
        },
        removeHooks: function() {
            ngr.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
        },
        _onDown: function(a) {
            if (a.touches)
                if (ngr.DomEvent.preventDefault(a),
                        this._fireClick = !0, 1 < a.touches.length) this._fireClick = !1, clearTimeout(this._holdTimeout);
                else {
                    var c = a.touches[0];
                    a = c.target;
                    this._startPos = this._newPos = new ngr.Point(c.clientX, c.clientY);
                    a.tagName && "a" === a.tagName.toLowerCase() && ngr.DomUtil.addClass(a, "ngr-active");
                    this._holdTimeout = setTimeout(ngr.bind(function() {
                        this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", c))
                    }, this), 1E3);
                    ngr.DomEvent.on(g, "touchmove", this._onMove, this).on(g, "touchend", this._onUp, this)
                }
        },
        _onUp: function(a) {
            clearTimeout(this._holdTimeout);
            ngr.DomEvent.off(g, "touchmove", this._onMove, this).off(g, "touchend", this._onUp, this);
            if (this._fireClick && a && a.changedTouches) {
                a = a.changedTouches[0];
                var c = a.target;
                c && c.tagName && "a" === c.tagName.toLowerCase() && ngr.DomUtil.removeClass(c, "ngr-active");
                this._isTapValid() && this._simulateEvent("click", a)
            }
        },
        _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
        },
        _onMove: function(a) {
            a = a.touches[0];
            this._newPos = new ngr.Point(a.clientX, a.clientY)
        },
        _simulateEvent: function(a,
                                 b) {
            var e = g.createEvent("MouseEvents");
            e._simulated = !0;
            b.target._simulatedClick = !0;
            e.initMouseEvent(a, !0, !0, d, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1, !1, !1, !1, 0, null);
            b.target.dispatchEvent(e)
        }
    });
    ngr.Browser.touch && !ngr.Browser.pointer && ngr.Map.addInitHook("addHandler", "tap", ngr.Map.Tap);
    ngr.Map.mergeOptions({
        boxZoom: !0
    });
    ngr.Map.BoxZoom = ngr.Handler.extend({
        initialize: function(a) {
            this._map = a;
            this._container = a._container;
            this._pane = a._panes.overlayPane;
            this._moved = !1
        },
        addHooks: function() {
            ngr.DomEvent.on(this._container,
                "mousedown", this._onMouseDown, this)
        },
        removeHooks: function() {
            ngr.DomEvent.off(this._container, "mousedown", this._onMouseDown);
            this._moved = !1
        },
        moved: function() {
            return this._moved
        },
        _onMouseDown: function(a) {
            this._moved = !1;
            if (!a.shiftKey || 1 !== a.which && 1 !== a.button) return !1;
            ngr.DomUtil.disableTextSelection();
            ngr.DomUtil.disableImageDrag();
            this._startLayerPoint = this._map.mouseEventToLayerPoint(a);
            ngr.DomEvent.on(g, "mousemove", this._onMouseMove, this).on(g, "mouseup", this._onMouseUp, this).on(g, "keydown", this._onKeyDown,
                this)
        },
        _onMouseMove: function(a) {
            this._moved || (this._box = ngr.DomUtil.create("div", "ngr-zoom-box", this._pane), ngr.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", this._map.fire("boxzoomstart"));
            var c = this._startLayerPoint,
                e = this._box,
                d = this._map.mouseEventToLayerPoint(a);
            a = d.subtract(c);
            c = new ngr.Point(Math.min(d.x, c.x), Math.min(d.y, c.y));
            ngr.DomUtil.setPosition(e, c);
            this._moved = !0;
            e.style.width = Math.max(0, Math.abs(a.x) - 4) + "px";
            e.style.height = Math.max(0, Math.abs(a.y) -
            4) + "px"
        },
        _finish: function() {
            this._moved && (this._pane.removeChild(this._box), this._container.style.cursor = "");
            ngr.DomUtil.enableTextSelection();
            ngr.DomUtil.enableImageDrag();
            ngr.DomEvent.off(g, "mousemove", this._onMouseMove).off(g, "mouseup", this._onMouseUp).off(g, "keydown", this._onKeyDown)
        },
        _onMouseUp: function(a) {
            this._finish();
            var c = this._map;
            a = c.mouseEventToLayerPoint(a);
            this._startLayerPoint.equals(a) || (a = new ngr.LatLngBounds(c.layerPointToLatLng(this._startLayerPoint), c.layerPointToLatLng(a)), c.fitBounds(a),
                c.fire("boxzoomend", {
                    boxZoomBounds: a
                }))
        },
        _onKeyDown: function(a) {
            27 === a.keyCode && this._finish()
        }
    });
    ngr.Map.addInitHook("addHandler", "boxZoom", ngr.Map.BoxZoom);
    ngr.Map.mergeOptions({
        keyboard: !0,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    });
    ngr.Map.Keyboard = ngr.Handler.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 173]
        },
        initialize: function(a) {
            this._map = a;
            this._setPanOffset(a.options.keyboardPanOffset);
            this._setZoomOffset(a.options.keyboardZoomOffset)
        },
        addHooks: function() {
            var a =
                this._map._container; - 1 === a.tabIndex && (a.tabIndex = "0");
            ngr.DomEvent.on(a, "focus", this._onFocus, this).on(a, "blur", this._onBlur, this).on(a, "mousedown", this._onMouseDown, this);
            this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
        },
        removeHooks: function() {
            this._removeHooks();
            var a = this._map._container;
            ngr.DomEvent.off(a, "focus", this._onFocus, this).off(a, "blur", this._onBlur, this).off(a, "mousedown", this._onMouseDown, this);
            this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks,
                this)
        },
        _onMouseDown: function() {
            if (!this._focused) {
                var a = g.body,
                    b = g.documentElement,
                    e = a.scrollTop || b.scrollTop,
                    a = a.scrollLeft || b.scrollLeft;
                this._map._container.focus();
                d.scrollTo(a, e)
            }
        },
        _onFocus: function() {
            this._focused = !0;
            this._map.fire("focus")
        },
        _onBlur: function() {
            this._focused = !1;
            this._map.fire("blur")
        },
        _setPanOffset: function(a) {
            var b = this._panKeys = {},
                e = this.keyCodes,
                d, g;
            d = 0;
            for (g = e.left.length; d < g; d++) b[e.left[d]] = [-1 * a, 0];
            d = 0;
            for (g = e.right.length; d < g; d++) b[e.right[d]] = [a, 0];
            d = 0;
            for (g = e.down.length; d <
            g; d++) b[e.down[d]] = [0, a];
            d = 0;
            for (g = e.up.length; d < g; d++) b[e.up[d]] = [0, -1 * a]
        },
        _setZoomOffset: function(a) {
            var b = this._zoomKeys = {},
                e = this.keyCodes,
                d, g;
            d = 0;
            for (g = e.zoomIn.length; d < g; d++) b[e.zoomIn[d]] = a;
            d = 0;
            for (g = e.zoomOut.length; d < g; d++) b[e.zoomOut[d]] = -a
        },
        _addHooks: function() {
            ngr.DomEvent.on(g, "keydown", this._onKeyDown, this)
        },
        _removeHooks: function() {
            ngr.DomEvent.off(g, "keydown", this._onKeyDown, this)
        },
        _onKeyDown: function(a) {
            var c = a.keyCode,
                e = this._map;
            if (c in this._panKeys) {
                if (e._panAnim && e._panAnim._inProgress) return;
                e.panBy(this._panKeys[c]);
                e.options.maxBounds && e.panInsideBounds(e.options.maxBounds)
            } else if (c in this._zoomKeys) e.setZoom(e.getZoom() + this._zoomKeys[c]);
            else return;
            ngr.DomEvent.stop(a)
        }
    });
    ngr.Map.addInitHook("addHandler", "keyboard", ngr.Map.Keyboard);
    ngr.Handler.MarkerDrag = ngr.Handler.extend({
        initialize: function(a) {
            this._marker = a
        },
        addHooks: function() {
            var a = this._marker._icon;
            this._draggable || (this._draggable = new ngr.Draggable(a, a));
            this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag,
                this).on("dragend", this._onDragEnd, this);
            this._draggable.enable();
            ngr.DomUtil.addClass(this._marker._icon, "ngr-marker-draggable")
        },
        removeHooks: function() {
            this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this);
            this._draggable.disable();
            ngr.DomUtil.removeClass(this._marker._icon, "ngr-marker-draggable")
        },
        moved: function() {
            return this._draggable && this._draggable._moved
        },
        _onDragStart: function() {
            this._marker.closePopup().fire("movestart").fire("dragstart")
        },
        _onDrag: function() {
            var a = this._marker,
                c = a._shadow,
                e = ngr.DomUtil.getPosition(a._icon),
                d = a._map.layerPointToLatLng(e);
            c && ngr.DomUtil.setPosition(c, e);
            a._latlng = d;
            a.fire("move", {
                latlng: d
            }).fire("drag")
        },
        _onDragEnd: function(a) {
            this._marker.fire("moveend").fire("dragend", a)
        }
    });
    ngr.Control = ngr.Class.extend({
        options: {
            position: "topright"
        },
        initialize: function(a) {
            ngr.setOptions(this, a)
        },
        getPosition: function() {
            return this.options.position
        },
        setPosition: function(a) {
            var b = this._map;
            b && b.removeControl(this);
            this.options.position =
                a;
            b && b.addControl(this);
            return this
        },
        getContainer: function() {
            return this._container
        },
        addTo: function(a) {
            this._map = a;
            var c = this._container = this.onAdd(a),
                e = this.getPosition();
            a = a._controlCorners[e];
            ngr.DomUtil.addClass(c, "ngr-control"); - 1 !== e.indexOf("bottom") ? a.insertBefore(c, a.firstChild) : a.appendChild(c);
            return this
        },
        removeFrom: function(a) {
            var b = this.getPosition();
            a._controlCorners[b].removeChild(this._container);
            this._map = null;
            if (this.onRemove) this.onRemove(a);
            return this
        },
        _refocusOnMap: function() {
            this._map &&
            this._map.getContainer().focus()
        }
    });
    ngr.control = function(a) {
        return new ngr.Control(a)
    };
    ngr.Map.include({
        addControl: function(a) {
            a.addTo(this);
            return this
        },
        removeControl: function(a) {
            a.removeFrom(this);
            return this
        },
        _initControlPos: function() {
            function a(a, d) {
                c[a + d] = ngr.DomUtil.create("div", "ngr-" + a + " ngr-" + d, e)
            }
            var c = this._controlCorners = {},
                e = this._controlContainer = ngr.DomUtil.create("div", "ngr-control-container", this._container);
            a("top", "left");
            a("top", "right");
            a("bottom", "left");
            a("bottom", "right")
        },
        _clearControlPos: function() {
            this._container.removeChild(this._controlContainer)
        }
    });
    ngr.Control.Zoom = ngr.Control.extend({
        options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "-",
            zoomOutTitle: "Zoom out"
        },
        onAdd: function(a) {
            var c = ngr.DomUtil.create("div", "ngr-control-zoom ngr-bar");
            this._map = a;
            this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, "ngr-control-zoom-in", c, this._zoomIn, this);
            this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, "ngr-control-zoom-out", c, this._zoomOut, this);
            this._updateDisabled();
            a.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return c
        },
        onRemove: function(a) {
            a.off("zoomend zoomlevelschange", this._updateDisabled, this)
        },
        _zoomIn: function(a) {
            this._map.zoomIn(a.shiftKey ? 3 : 1)
        },
        _zoomOut: function(a) {
            this._map.zoomOut(a.shiftKey ? 3 : 1)
        },
        _createButton: function(a, c, e, d, g, h) {
            e = ngr.DomUtil.create("a", e, d);
            e.innerHTML = a;
            e.href = "#";
            e.title = c;
            a = ngr.DomEvent.stopPropagation;
            ngr.DomEvent.on(e, "click", a).on(e, "mousedown", a).on(e, "dblclick", a).on(e, "click", ngr.DomEvent.preventDefault).on(e, "click",
                g, h).on(e, "click", this._refocusOnMap, h);
            return e
        },
        _updateDisabled: function() {
            var a = this._map;
            ngr.DomUtil.removeClass(this._zoomInButton, "ngr-disabled");
            ngr.DomUtil.removeClass(this._zoomOutButton, "ngr-disabled");
            a._zoom === a.getMinZoom() && ngr.DomUtil.addClass(this._zoomOutButton, "ngr-disabled");
            a._zoom === a.getMaxZoom() && ngr.DomUtil.addClass(this._zoomInButton, "ngr-disabled")
        }
    });
    ngr.Map.mergeOptions({
        zoomControl: !0
    });
    ngr.Map.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new ngr.Control.Zoom,
            this.addControl(this.zoomControl))
    });
    ngr.control.zoom = function(a) {
        return new ngr.Control.Zoom(a)
    };
    ngr.Control.Attribution = ngr.Control.extend({
        options: {
            position: "bottomright",
            prefix: ""
        },
        initialize: function(a) {
            ngr.setOptions(this, a);
            this._attributions = {}
        },
        onAdd: function(a) {
            this._container = ngr.DomUtil.create("div", "ngr-control-attribution");
            ngr.DomEvent.disableClickPropagation(this._container);
            for (var c in a._layers) a._layers[c].getAttribution && this.addAttribution(a._layers[c].getAttribution());
            a.on("layeradd", this._onLayerAdd,
                this).on("layerremove", this._onLayerRemove, this);
            this._update();
            return this._container
        },
        onRemove: function(a) {
            a.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
        },
        setPrefix: function(a) {
            this.options.prefix = a;
            this._update();
            return this
        },
        addAttribution: function(a) {
            if (a) return this._attributions[a] || (this._attributions[a] = 0), this._attributions[a]++, this._update(), this
        },
        removeAttribution: function(a) {
            if (a) return this._attributions[a] && (this._attributions[a]--, this._update()), this
        },
        _update: function() {
            if (this._map) {
                var a = [],
                    b;
                for (b in this._attributions) this._attributions[b] && a.push(b);
                b = [];
                this.options.prefix && b.push(this.options.prefix);
                a.length && b.push(a.join(", "));
                this._container.innerHTML = b.join(" | ")
            }
        },
        _onLayerAdd: function(a) {
            a.layer.getAttribution && this.addAttribution(a.layer.getAttribution())
        },
        _onLayerRemove: function(a) {
            a.layer.getAttribution && this.removeAttribution(a.layer.getAttribution())
        }
    });
    ngr.Map.addInitHook(function() {
        this.options.attributionControl && (this.attributionControl =
            (new ngr.Control.Attribution).addTo(this))
    });
    ngr.control.attribution = function(a) {
        return new ngr.Control.Attribution(a)
    };
    ngr.Control.Scale = ngr.Control.extend({
        options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: !0,
            imperial: !0,
            updateWhenIdle: !1
        },
        onAdd: function(a) {
            this._map = a;
            var c = ngr.DomUtil.create("div", "ngr-control-scale"),
                e = this.options;
            this._addScales(e, "ngr-control-scale", c);
            a.on(e.updateWhenIdle ? "moveend" : "move", this._update, this);
            a.whenReady(this._update, this);
            return c
        },
        onRemove: function(a) {
            a.off(this.options.updateWhenIdle ?
                "moveend" : "move", this._update, this)
        },
        _addScales: function(a, c, e) {
            a.metric && (this._mScale = ngr.DomUtil.create("div", c + "-line", e));
            a.imperial && (this._iScale = ngr.DomUtil.create("div", c + "-line", e))
        },
        _update: function() {
            var a = this._map.getBounds(),
                b = a.getCenter().lat,
                a = 6378137 * Math.PI * Math.cos(b * Math.PI / 180) * (a.getNorthEast().lng - a.getSouthWest().lng) / 180,
                b = this._map.getSize(),
                e = this.options,
                d = 0;
            0 < b.x && (d = e.maxWidth / b.x * a);
            this._updateScales(e, d)
        },
        _updateScales: function(a, b) {
            a.metric && b && this._updateMetric(b);
            a.imperial && b && this._updateImperial(b)
        },
        _updateMetric: function(a) {
            var b = this._getRoundNum(a);
            this._mScale.style.width = this._getScaleWidth(b / a) + "px";
            this._mScale.innerHTML = 1E3 > b ? b + " m" : b / 1E3 + " km"
        },
        _updateImperial: function(a) {
            var b = 3.2808399 * a;
            a = this._iScale;
            var e;
            5280 < b ? (b /= 5280, e = this._getRoundNum(b), a.style.width = this._getScaleWidth(e / b) + "px", a.innerHTML = e + " mi") : (e = this._getRoundNum(b), a.style.width = this._getScaleWidth(e / b) + "px", a.innerHTML = e + " ft")
        },
        _getScaleWidth: function(a) {
            return Math.round(this.options.maxWidth *
                a) - 10
        },
        _getRoundNum: function(a) {
            var b = Math.pow(10, (Math.floor(a) + "").length - 1);
            a /= b;
            return b * (10 <= a ? 10 : 5 <= a ? 5 : 3 <= a ? 3 : 2 <= a ? 2 : 1)
        }
    });
    ngr.control.scale = function(a) {
        return new ngr.Control.Scale(a)
    };
    ngr.Control.Layers = ngr.Control.extend({
        options: {
            collapsed: !0,
            position: "topright",
            autoZIndex: !0
        },
        initialize: function(a, c, e) {
            ngr.setOptions(this, e);
            this._layers = {};
            this._lastZIndex = 0;
            this._handlingClick = !1;
            for (var d in a) this._addLayer(a[d], d);
            for (d in c) this._addLayer(c[d], d, !0)
        },
        onAdd: function(a) {
            this._initLayout();
            this._update();
            a.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this);
            return this._container
        },
        onRemove: function(a) {
            a.off("layeradd", this._onLayerChange, this).off("layerremove", this._onLayerChange, this)
        },
        addBaseLayer: function(a, b) {
            this._addLayer(a, b);
            this._update();
            return this
        },
        addOverlay: function(a, b) {
            this._addLayer(a, b, !0);
            this._update();
            return this
        },
        removeLayer: function(a) {
            a = ngr.stamp(a);
            delete this._layers[a];
            this._update();
            return this
        },
        _initLayout: function() {
            var a = this._container =
                ngr.DomUtil.create("div", "ngr-control-layers");
            a.setAttribute("aria-haspopup", !0);
            if (ngr.Browser.touch) ngr.DomEvent.on(a, "click", ngr.DomEvent.stopPropagation);
            else ngr.DomEvent.disableClickPropagation(a).disableScrollPropagation(a);
            var c = this._form = ngr.DomUtil.create("form", "ngr-control-layers-list");
            if (this.options.collapsed) {
                if (!ngr.Browser.android) ngr.DomEvent.on(a, "mouseover", this._expand, this).on(a, "mouseout", this._collapse, this);
                var e = this._layersLink = ngr.DomUtil.create("a", "ngr-control-layers-toggle", a);
                e.href =
                    "#";
                e.title = "Layers";
                if (ngr.Browser.touch) ngr.DomEvent.on(e, "click", ngr.DomEvent.stop).on(e, "click", this._expand, this);
                else ngr.DomEvent.on(e, "focus", this._expand, this);
                ngr.DomEvent.on(c, "click", function() {
                    setTimeout(ngr.bind(this._onInputClick, this), 0)
                }, this);
                this._map.on("click", this._collapse, this)
            } else this._expand();
            this._baseLayersList = ngr.DomUtil.create("div", "ngr-control-layers-base", c);
            this._separator = ngr.DomUtil.create("div", "ngr-control-layers-separator", c);
            this._overlaysList = ngr.DomUtil.create("div", "ngr-control-layers-overlays",
                c);
            a.appendChild(c)
        },
        _addLayer: function(a, c, e) {
            var d = ngr.stamp(a);
            this._layers[d] = {
                layer: a,
                name: c,
                overlay: e
            };
            this.options.autoZIndex && a.setZIndex && (this._lastZIndex++, a.setZIndex(this._lastZIndex))
        },
        _update: function() {
            if (this._container) {
                this._baseLayersList.innerHTML = "";
                this._overlaysList.innerHTML = "";
                var a = !1,
                    b = !1,
                    e, d;
                for (e in this._layers) d = this._layers[e], this._addItem(d), b = b || d.overlay, a = a || !d.overlay;
                this._separator.style.display = b && a ? "" : "none"
            }
        },
        _onLayerChange: function(a) {
            var c = this._layers[ngr.stamp(a.layer)];
            c && (this._handlingClick || this._update(), (a = c.overlay ? "layeradd" === a.type ? "overlayadd" : "overlayremove" : "layeradd" === a.type ? "baselayerchange" : null) && this._map.fire(a, c))
        },
        _createRadioElement: function(a, b) {
            var e = '<input type="radio" class="ngr-control-layers-selector" name="' + a + '"';
            b && (e += ' checked="checked"');
            var e = e + "/>",
                d = g.createElement("div");
            d.innerHTML = e;
            return d.firstChild
        },
        _addItem: function(a) {
            var c = g.createElement("label"),
                e, d = this._map.hasLayer(a.layer);
            a.overlay ? (e = g.createElement("input"),
                e.type = "checkbox", e.className = "ngr-control-layers-selector", e.defaultChecked = d) : e = this._createRadioElement("ngr-base-layers", d);
            e.layerId = ngr.stamp(a.layer);
            ngr.DomEvent.on(e, "click", this._onInputClick, this);
            d = g.createElement("span");
            d.innerHTML = " " + a.name;
            c.appendChild(e);
            c.appendChild(d);
            (a.overlay ? this._overlaysList : this._baseLayersList).appendChild(c);
            return c
        },
        _onInputClick: function() {
            var a, b, e, d = this._form.getElementsByTagName("input"),
                g = d.length;
            this._handlingClick = !0;
            for (a = 0; a < g; a++) b = d[a], e =
                this._layers[b.layerId], b.checked && !this._map.hasLayer(e.layer) ? this._map.addLayer(e.layer) : !b.checked && this._map.hasLayer(e.layer) && this._map.removeLayer(e.layer);
            this._handlingClick = !1;
            this._refocusOnMap()
        },
        _expand: function() {
            ngr.DomUtil.addClass(this._container, "ngr-control-layers-expanded")
        },
        _collapse: function() {
            this._container.className = this._container.className.replace(" ngr-control-layers-expanded", "")
        }
    });
    ngr.control.layers = function(a, c, e) {
        return new ngr.Control.Layers(a, c, e)
    };
    ngr.PosAnimation = ngr.Class.extend({
        includes: ngr.Mixin.Events,
        run: function(a, c, e, d) {
            this.stop();
            this._el = a;
            this._inProgress = !0;
            this._newPos = c;
            this.fire("start");
            a.style[ngr.DomUtil.TRANSITION] = "all " + (e || .25) + "s cubic-bezier(0,0," + (d || .5) + ",1)";
            ngr.DomEvent.on(a, ngr.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            ngr.DomUtil.setPosition(a, c);
            ngr.Util.falseFn(a.offsetWidth);
            this._stepTimer = setInterval(ngr.bind(this._onStep, this), 50)
        },
        stop: function() {
            this._inProgress && (ngr.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), ngr.Util.falseFn(this._el.offsetWidth))
        },
        _onStep: function() {
            var a = this._getPos();
            a ? (this._el._ngr_pos = a, this.fire("step")) : this._onTransitionEnd()
        },
        _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
        _getPos: function() {
            var a, c;
            c = d.getComputedStyle(this._el);
            if (ngr.Browser.any3d) {
                c = c[ngr.DomUtil.TRANSFORM].match(this._transformRe);
                if (!c) return;
                a = parseFloat(c[1]);
                c = parseFloat(c[2])
            } else a = parseFloat(c.left), c = parseFloat(c.top);
            return new ngr.Point(a, c, !0)
        },
        _onTransitionEnd: function() {
            ngr.DomEvent.off(this._el, ngr.DomUtil.TRANSITION_END,
                this._onTransitionEnd, this);
            this._inProgress && (this._inProgress = !1, this._el.style[ngr.DomUtil.TRANSITION] = "", this._el._ngr_pos = this._newPos, clearInterval(this._stepTimer), this.fire("step").fire("end"))
        }
    });
    ngr.Map.include({
        setView: function(a, c, e) {
            c = c === h ? this._zoom : this._limitZoom(c);
            a = this._limitCenter(ngr.latLng(a), c, this.options.maxBounds);
            e = e || {};
            this._panAnim && this._panAnim.stop();
            if (this._loaded && !e.reset && !0 !== e && (e.animate !== h && (e.zoom = ngr.extend({
                    animate: e.animate
                }, e.zoom), e.pan = ngr.extend({
                        animate: e.animate
                    },
                    e.pan)), this._zoom !== c ? this._tryAnimatedZoom && this._tryAnimatedZoom(a, c, e.zoom) : this._tryAnimatedPan(a, e.pan))) return clearTimeout(this._sizeTimer), this;
            this._resetView(a, c);
            return this
        },
        panBy: function(a, c) {
            a = ngr.point(a).round();
            c = c || {};
            if (!a.x && !a.y) return this;
            this._panAnim || (this._panAnim = new ngr.PosAnimation, this._panAnim.on({
                step: this._onPanTransitionStep,
                end: this._onPanTransitionEnd
            }, this));
            c.noMoveStart || this.fire("movestart");
            if (!1 !== c.animate) {
                ngr.DomUtil.addClass(this._mapPane, "ngr-pan-anim");
                var e = this._getMapPanePos().subtract(a);
                this._panAnim.run(this._mapPane, e, c.duration || .25, c.easeLinearity)
            } else this._rawPanBy(a), this.fire("move").fire("moveend");
            return this
        },
        _onPanTransitionStep: function() {
            this.fire("move")
        },
        _onPanTransitionEnd: function() {
            ngr.DomUtil.removeClass(this._mapPane, "ngr-pan-anim");
            ngr.Browser.mobile && 0 < Object.keys(NGR.Cache._imageCache).length ? this._delayId || (this._delayId = setTimeout(function() {
                this._delayId = null;
                this.fire("moveend")
            }.bind(this), 500)) : this.fire("moveend")
        },
        _tryAnimatedPan: function(a, b) {
            var e = this._getCenterOffset(a)._floor();
            if (!0 !== (b && b.animate) && !this.getSize().contains(e)) return !1;
            this.panBy(e, b);
            return !0
        }
    });
    ngr.PosAnimation = ngr.DomUtil.TRANSITION ? ngr.PosAnimation : ngr.PosAnimation.extend({
        run: function(a, c, e, d) {
            this.stop();
            this._el = a;
            this._inProgress = !0;
            this._duration = e || .25;
            this._easeOutPower = 1 / Math.max(d || .5, .2);
            this._startPos = ngr.DomUtil.getPosition(a);
            this._offset = c.subtract(this._startPos);
            this._startTime = +new Date;
            this.fire("start");
            this._animate()
        },
        stop: function() {
            this._inProgress && (this._step(), this._complete())
        },
        _animate: function() {
            this._animId = ngr.Util.requestAnimFrame(this._animate, this);
            this._step()
        },
        _step: function() {
            var a = +new Date - this._startTime,
                b = 1E3 * this._duration;
            a < b ? this._runFrame(this._easeOut(a / b)) : (this._runFrame(1), this._complete())
        },
        _runFrame: function(a) {
            a = this._startPos.add(this._offset.multiplyBy(a));
            ngr.DomUtil.setPosition(this._el, a);
            this.fire("step")
        },
        _complete: function() {
            ngr.Util.cancelAnimFrame(this._animId);
            this._inProgress = !1;
            this.fire("end")
        },
        _easeOut: function(a) {
            return 1 - Math.pow(1 - a, this._easeOutPower)
        }
    });
    ngr.Map.mergeOptions({
        zoomAnimation: !0,
        zoomAnimationThreshold: 4
    });
    ngr.DomUtil.TRANSITION && ngr.Map.addInitHook(function() {
        if (this._zoomAnimated = this.options.zoomAnimation && ngr.DomUtil.TRANSITION && ngr.Browser.any3d && !ngr.Browser.android23 && !ngr.Browser.mobileOpera) ngr.DomEvent.on(this._mapPane, ngr.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
    });
    ngr.Map.include(ngr.DomUtil.TRANSITION ? {
        _catchTransitionEnd: function(a) {
            this._animatingZoom &&
            0 <= a.propertyName.indexOf("transform") && this._onZoomTransitionEnd()
        },
        _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("ngr-zoom-animated").length
        },
        _tryAnimatedZoom: function(a, b, e) {
            if (this._animatingZoom) return !0;
            e = e || {};
            if (!this._zoomAnimated || !1 === e.animate || this._nothingToAnimate() || Math.abs(b - this._zoom) > this.options.zoomAnimationThreshold) return !1;
            var d = this.getZoomScale(b),
                g = this._getCenterOffset(a)._divideBy(1 - 1 / d),
                h = this._getCenterLayerPoint()._add(g);
            if (!0 !== e.animate &&
                !this.getSize().contains(g)) return !1;
            this.fire("movestart").fire("zoomstart");
            this._animateZoom(a, b, h, d, null, !0);
            return !0
        },
        _animateZoom: function(a, c, e, d, g, h, k) {
            k || (this._animatingZoom = !0);
            ngr.DomUtil.addClass(this._mapPane, "ngr-zoom-anim");
            this._animateToCenter = a;
            this._animateToZoom = c;
            ngr.Draggable && (ngr.Draggable._disabled = !0);
            ngr.Util.requestAnimFrame(function() {
                this.fire("zoomanim", {
                    center: a,
                    zoom: c,
                    origin: e,
                    scale: d,
                    delta: g,
                    backwards: h
                })
            }, this)
        },
        _onZoomTransitionEnd: function() {
            this._animatingZoom = !1;
            ngr.DomUtil.removeClass(this._mapPane,
                "ngr-zoom-anim");
            this._resetView(this._animateToCenter, this._animateToZoom, !0, !0);
            ngr.Draggable && (ngr.Draggable._disabled = !1)
        }
    } : {});
    ngr.TileLayer.include({
        _animateZoom: function(a) {
            this._animating || (this._animating = !0, this._prepareBgBuffer());
            var c = this._bgBuffer,
                e = ngr.DomUtil.TRANSFORM,
                d = a.delta ? ngr.DomUtil.getTranslateString(a.delta) : c.style[e],
                g = ngr.DomUtil.getScaleString(a.scale, a.origin);
            c.style[e] = a.backwards ? g + " " + d : d + " " + g
        },
        _endZoomAnim: function() {
            var a = this._tileContainer,
                c = this._bgBuffer;
            a.style.visibility =
                "";
            a.parentNode.appendChild(a);
            ngr.Util.falseFn(c.offsetWidth);
            this._animating = !1
        },
        _clearBgBuffer: function() {
            var a = this._map;
            !a || a._animatingZoom || a.touchZoom._zooming || (this._bgBuffer.innerHTML = "", this._bgBuffer.style[ngr.DomUtil.TRANSFORM] = "")
        },
        _prepareBgBuffer: function() {
            var a = this._tileContainer,
                c = this._bgBuffer,
                d = this._getLoadedTilesPercentage(c),
                f = this._getLoadedTilesPercentage(a);
            c && .5 < d && .5 > f ? (a.style.visibility = "hidden", this._stopLoadingImages(a)) : (c.style.visibility = "hidden", c.style[ngr.DomUtil.TRANSFORM] =
                "", this._tileContainer = c, c = this._bgBuffer = a, this._stopLoadingImages(c), clearTimeout(this._clearBgBufferTimer))
        },
        _getLoadedTilesPercentage: function(a) {
            a = a.getElementsByTagName("img");
            var b, d, f = 0;
            b = 0;
            for (d = a.length; b < d; b++) a[b].complete && f++;
            return f / d
        },
        _stopLoadingImages: function(a) {
            a = Array.prototype.slice.call(a.getElementsByTagName("img"));
            var c, d, f;
            c = 0;
            for (d = a.length; c < d; c++) f = a[c], f.complete || (f.onload = ngr.Util.falseFn, f.onerror = ngr.Util.falseFn, f.src = ngr.Util.emptyImageUrl, f.parentNode.removeChild(f))
        }
    });
    ngr.Map.include({
        _defaultLocateOptions: {
            watch: !1,
            setView: !1,
            maxZoom: Infinity,
            timeout: 1E4,
            maximumAge: 0,
            enableHighAccuracy: !1
        },
        locate: function(a) {
            a = this._locateOptions = ngr.extend(this._defaultLocateOptions, a);
            if (!navigator.geolocation) return this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
            }), this;
            var c = ngr.bind(this._handleGeolocationResponse, this),
                d = ngr.bind(this._handleGeolocationError, this);
            a.watch ? this._locationWatchId = navigator.geolocation.watchPosition(c, d, a) : navigator.geolocation.getCurrentPosition(c,
                d, a);
            return this
        },
        stopLocate: function() {
            navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId);
            this._locateOptions && (this._locateOptions.setView = !1);
            return this
        },
        _handleGeolocationError: function(a) {
            var b = a.code;
            a = a.message || (1 === b ? "permission denied" : 2 === b ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld();
            this.fire("locationerror", {
                code: b,
                message: "Geolocation error: " + a + "."
            })
        },
        _handleGeolocationResponse: function(a) {
            var c = a.coords.latitude,
                d = a.coords.longitude,
                f = new ngr.LatLng(c, d),
                g = 180 * a.coords.accuracy / 40075017,
                h = g / Math.cos(ngr.LatLng.DEG_TO_RAD * c),
                c = ngr.latLngBounds([c - g, d - h], [c + g, d + h]),
                d = this._locateOptions;
            d.setView && (d = Math.min(this.getBoundsZoom(c), d.maxZoom), this.setView(f, d));
            var f = {
                    latlng: f,
                    bounds: c,
                    timestamp: a.timestamp
                },
                k;
            for (k in a.coords) "number" === typeof a.coords[k] && (f[k] = a.coords[k]);
            this.fire("locationfound", f)
        }
    })
})(window, document);
L.HeatLayer = (L.Layer ? L.Layer : L.Class).extend({
    initialize: function(d, g) {
        this._latlngs = d;
        this._latlngMap = {};
        this._isMoving = this._useLatLngMap = !1;
        L.setOptions(this, g)
    },
    setLatLngs: function(d) {
        this._latlngs = d;
        this._useLatLngMap = !1;
        return this.redraw()
    },
    addLatLng: function(d) {
        this._latlngs.push(d);
        this._useLatLngMap = !1;
        return this.redraw()
    },
    setLatLngMap: function(d) {
        this._useLatLngMap = !0;
        this._latlngMap = d;
        return this.redraw()
    },
    updateInLatLngMap: function(d, g) {
        this._useLatLngMap = !0;
        this._latlngMap[d] = g;
        return this.redraw()
    },
    removeFromLatLngMap: function(d) {
        this._useLatLngMap = !0;
        delete this._latlngMap[d];
        return this.redraw()
    },
    setOptions: function(d) {
        L.setOptions(this, d);
        this._heat && this._updateOptions();
        return this.redraw()
    },
    redraw: function() {
        !this._heat || this._frame || this._map._animating || (this._frame = L.Util.requestAnimFrame(this._redraw, this));
        return this
    },
    onAdd: function(d) {
        this._map = d;
        this._canvas || this._initCanvas();
        d._panes.overlayPane.appendChild(this._canvas);
        d.on("movestart", function() {
            this._isMoving = !0
        }, this);
        d.on("moveend", this._reset, this);
        if (d.options.zoomAnimation && L.Browser.any3d) d.on("zoomanim", this._animateZoom, this);
        this._reset()
    },
    onRemove: function(d) {
        d.getPanes().overlayPane.removeChild(this._canvas);
        d.off("moveend", this._reset, this);
        d.options.zoomAnimation && d.off("zoomanim", this._animateZoom, this);
        this._latlngs.length = 0;
        delete this._latlngs;
        delete this._latlngMap
    },
    addTo: function(d) {
        d.addLayer(this);
        return this
    },
    _initCanvas: function() {
        var d = this._canvas = L.DomUtil.create("canvas", "ngr-heatmap-layer ngr-layer"),
            g = this._map.getSize();
        d.width = g.x;
        d.height = g.y;
        L.DomUtil.addClass(d, "ngr-zoom-" + (this._map.options.zoomAnimation && L.Browser.any3d ? "animated" : "hide"));
        this._heat = simpleheat(d);
        this._updateOptions()
    },
    _updateOptions: function() {
        this._heat.radius(this.options.radius || this._heat.defaultRadius, this.options.blur);
        this.options.gradient && this._heat.gradient(this.options.gradient);
        this.options.max && this._heat.max(this.options.max)
    },
    _reset: function() {
        this._isMoving = !1;
        var d = this._map.containerPointToLayerPoint([0,
            0
        ]);
        L.DomUtil.setPosition(this._canvas, d);
        d = this._map.getSize();
        this._heat._width !== d.x && (this._canvas.width = this._heat._width = d.x);
        this._heat._height !== d.y && (this._canvas.height = this._heat._height = d.y);
        this._redraw()
    },
    _redraw: function() {
        if (!this._isMoving) {
            var d = [],
                g = this._heat._r,
                h = this._map.getSize(),
                k = new L.LatLngBounds(this._map.containerPointToLatLng(L.point([-g, -g])), this._map.containerPointToLatLng(h.add([g, g]))),
                h = void 0 === this.options.maxZoom ? this._map.getMaxZoom() : this.options.maxZoom,
                b = 1 / Math.pow(2, Math.max(0, Math.min(h - this._map.getZoom(), 12))),
                l = g / 2,
                a = [],
                g = this._map._getMapPanePos(),
                c = g.x % l,
                e = g.y % l,
                f, m, p, v, r, n, q, t = this,
                h = function(d) {
                    k.contains(d) && (m = t._map.latLngToContainerPoint(d), v = Math.floor((m.x - c) / l) + 2, r = Math.floor((m.y - e) / l) + 2, q = (void 0 !== d.alt ? d.alt : void 0 !== d[2] ? +d[2] : 1) * b, a[r] = a[r] || [], (p = a[r][v]) ? (p[0] = (p[0] * p[2] + m.x * q) / (p[2] + q), p[1] = (p[1] * p[2] + m.y * q) / (p[2] + q), p[2] += q) : a[r][v] = [m.x, m.y, q])
                };
            if (this._useLatLngMap)
                for (f in this._latlngMap) h(this._latlngMap[f]);
            else
                for (f =
                         0, g = this._latlngs.length; f < g; f++) h(this._latlngs[f]);
            f = 0;
            for (g = a.length; f < g; f++)
                if (a[f])
                    for (h = 0, n = a[f].length; h < n; h++)(p = a[f][h]) && d.push([Math.round(p[0]), Math.round(p[1]), Math.min(p[2], 1)]);
            this._heat.data(d).draw(this.options.minOpacity);
            this._frame = null
        }
    },
    _animateZoom: function(d) {
        var g = this._map.getZoomScale(d.zoom);
        d = this._map._getCenterOffset(d.center)._multiplyBy(-g).subtract(this._map._getMapPanePos());
        L.DomUtil.setTransform ? L.DomUtil.setTransform(this._canvas, d, g) : this._canvas.style[L.DomUtil.TRANSFORM] =
            L.DomUtil.getTranslateString(d) + " scale(" + g + ")"
    }
});
L.heatLayer = function(d, g) {
    return new L.HeatLayer(d, g)
};
(function() {
    function d(g) {
        if (!(this instanceof d)) return new d(g);
        this._canvas = g = "string" === typeof g ? document.getElementById(g) : g;
        this._ctx = g.getContext("2d");
        this._width = g.width;
        this._height = g.height;
        this._bufferedCanvas = document.createElement("canvas");
        this._bufferedCanvas.width = g.width;
        this._bufferedCanvas.height = g.height;
        this._bufferedCtx = this._bufferedCanvas.getContext("2d");
        this._max = 1;
        this._data = []
    }
    d.prototype = {
        defaultRadius: 25,
        defaultGradient: {
            "0.4": "blue",
            "0.6": "cyan",
            "0.7": "lime",
            "0.8": "yellow",
            1: "red"
        },
        data: function(d) {
            this._data = d;
            return this
        },
        max: function(d) {
            this._max = d;
            return this
        },
        add: function(d) {
            this._data.push(d);
            return this
        },
        clear: function() {
            this._data = [];
            return this
        },
        radius: function(d, h) {
            h = h || 15;
            var k = this._circle = document.createElement("canvas"),
                b = k.getContext("2d"),
                l = this._r = d + h;
            k.width = k.height = 2 * l;
            b.shadowOffsetX = b.shadowOffsetY = 200;
            b.shadowBlur = h;
            b.shadowColor = "black";
            b.beginPath();
            b.arc(l - 200, l - 200, d, 0, 2 * Math.PI, !0);
            b.closePath();
            b.fill();
            return this
        },
        gradient: function(d) {
            var h =
                    document.createElement("canvas"),
                k = h.getContext("2d"),
                b = k.createLinearGradient(0, 0, 0, 256);
            h.width = 1;
            h.height = 256;
            for (var l in d) b.addColorStop(l, d[l]);
            k.fillStyle = b;
            k.fillRect(0, 0, 1, 256);
            this._grad = k.getImageData(0, 0, 1, 256).data;
            return this
        },
        draw: function(d) {
            this._circle || this.radius(this.defaultRadius);
            this._grad || this.gradient(this.defaultGradient);
            var h = this._ctx,
                k = this._bufferedCtx;
            k.clearRect(0, 0, this._width, this._height);
            for (var b = 0, l = this._data.length, a; b < l; b++) a = this._data[b], k.globalAlpha =
                Math.max(a[2] / this._max, void 0 === d ? .05 : d), k.drawImage(this._circle, a[0] - this._r, a[1] - this._r);
            d = k.getImageData(0, 0, this._width, this._height);
            this._colorize(d.data, this._grad);
            h.putImageData(d, 0, 0);
            return this
        },
        _colorize: function(d, h) {
            for (var k = 3, b = d.length, l; k < b; k += 4)
                if (l = 4 * d[k]) d[k - 3] = h[l], d[k - 2] = h[l + 1], d[k - 1] = h[l + 2]
        }
    };
    window.simpleheat = d
})();
(function(d) {
    "function" === typeof bootstrap ? bootstrap("promise", d) : "object" === typeof exports ? module.exports = d() : "function" === typeof define && define.amd ? define(d) : "undefined" !== typeof ses ? ses.ok() && (ses.makeQ = d) : Q = d()
})(
    function() {
    function d(a) {
        return function() {
            return P.apply(a, arguments)
        }
    }

    function g(a, b) {
        if (z && b.stack && "object" === typeof a && null !== a && a.stack && -1 === a.stack.indexOf("From previous event:")) {
            for (var c = [], d = b; d; d = d.source) d.stack && c.unshift(d.stack);
            c.unshift(a.stack);
            for (var c = c.join("\nFrom previous event:\n").split("\n"),
                     d = [], e = 0; e < c.length; ++e) {
                var f = c[e],
                    g;
                if (g = h(f)) {
                    var k = g[1];
                    g = g[0] === M && k >= O && k <= R
                } else g = !1;
                g || (g = f, g = -1 !== g.indexOf("(module.js:") || -1 !== g.indexOf("(node.js:"));
                g || !f || d.push(f)
            }
            c = d.join("\n");
            a.stack = c
        }
    }

    function h(a) {
        var b = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(a);
        if (b || (b = /at ([^ ]+):(\d+):(?:\d+)$/.exec(a))) return [b[1], Number(b[2])];
        if (a = /.*@(.+):(\d+)$/.exec(a)) return [a[1], Number(a[2])]
    }

    function k() {
        if (z) try {
            throw Error();
        } catch (a) {
            var b = a.stack.split("\n"),
                b = 0 < b[0].indexOf("@") ? b[1] : b[2];
            if (b =
                    h(b)) return M = b[0], b[1]
        }
    }

    function b(a) {
        return p(a) ? a : v(a) ? y(a) : t(a)
    }

    function l() {
        function a(b) {
            f = b;
            h.source = b;
            E(c, function(a, c) {
                w(function() {
                    b.promiseDispatch.apply(b, c)
                })
            }, void 0);
            d = c = void 0
        }
        var c = [],
            d = [],
            f, g = H(l.prototype),
            h = H(e.prototype);
        h.promiseDispatch = function(a, b, e) {
            var g = u(arguments);
            c ? (c.push(g), "when" === b && e[1] && d.push(e[1])) : w(function() {
                f.promiseDispatch.apply(f, g)
            })
        };
        h.valueOf = function() {
            if (c) return h;
            var a = m(f);
            p(a) && (f = a);
            return a
        };
        h.inspect = function() {
            return f ? f.inspect() : {
                state: "pending"
            }
        };
        if (b.longStackSupport && z) try {
            throw Error();
        } catch (k) {
            h.stack = k.stack.substring(k.stack.indexOf("\n") + 1)
        }
        g.promise = h;
        g.resolve = function(c) {
            f || a(b(c))
        };
        g.fulfill = function(b) {
            f || a(t(b))
        };
        g.reject = function(b) {
            f || a(q(b))
        };
        g.notify = function(a) {
            f || E(d, function(b, c) {
                w(function() {
                    c(a)
                })
            }, void 0)
        };
        return g
    }

    function a(a) {
        if ("function" !== typeof a) throw new TypeError("resolver must be a function.");
        var b = l();
        try {
            a(b.resolve, b.reject, b.notify)
        } catch (c) {
            b.reject(c)
        }
        return b.promise
    }

    function c(c) {
        return a(function(a,
                          d) {
            for (var e = 0, f = c.length; e < f; e++) b(c[e]).then(a, d)
        })
    }

    function e(a, b, c) {
        void 0 === b && (b = function(a) {
            return q(Error("Promise does not support operation: " + a))
        });
        void 0 === c && (c = function() {
            return {
                state: "unknown"
            }
        });
        var d = H(e.prototype);
        d.promiseDispatch = function(c, e, f) {
            var g;
            try {
                g = a[e] ? a[e].apply(d, f) : b.call(d, e, f)
            } catch (h) {
                g = q(h)
            }
            c && c(g)
        };
        if (d.inspect = c) {
            var f = c();
            "rejected" === f.state && (d.exception = f.reason);
            d.valueOf = function() {
                var a = c();
                return "pending" === a.state || "rejected" === a.state ? d : a.value
            }
        }
        return d
    }

    function f(a, c, d, e) {
        return b(a).then(c, d, e)
    }

    function m(a) {
        if (p(a)) {
            var b = a.inspect();
            if ("fulfilled" === b.state) return b.value
        }
        return a
    }

    function p(a) {
        return a === Object(a) && "function" === typeof a.promiseDispatch && "function" === typeof a.inspect
    }

    function v(a) {
        return a === Object(a) && "function" === typeof a.then
    }

    function r() {
        C.length = 0;
        F.length = 0;
        D || (D = !0)
    }

    function n(a, b) {
        D && (F.push(a), b && "undefined" !== typeof b.stack ? C.push(b.stack) : C.push("(no stack) " + b))
    }

    function q(a) {
        var b = e({
            when: function(b) {
                if (b && D) {
                    var c =
                        S(F, this); - 1 !== c && (F.splice(c, 1), C.splice(c, 1))
                }
                return b ? b(a) : this
            }
        }, function() {
            return this
        }, function() {
            return {
                state: "rejected",
                reason: a
            }
        });
        n(b, a);
        return b
    }

    function t(a) {
        return e({
            when: function() {
                return a
            },
            get: function(b) {
                return a[b]
            },
            set: function(b, c) {
                a[b] = c
            },
            "delete": function(b) {
                delete a[b]
            },
            post: function(b, c) {
                return null === b || void 0 === b ? a.apply(void 0, c) : a[b].apply(a, c)
            },
            apply: function(b, c) {
                return a.apply(b, c)
            },
            keys: function() {
                return T(a)
            }
        }, void 0, function() {
            return {
                state: "fulfilled",
                value: a
            }
        })
    }

    function y(a) {
        var b = l();
        w(function() {
            try {
                a.then(b.resolve, b.reject, b.notify)
            } catch (c) {
                b.reject(c)
            }
        });
        return b.promise
    }

    function K(a, c, d) {
        return b(a).spread(c, d)
    }

    function A(a, c, d) {
        return b(a).dispatch(c, d)
    }

    function x(a) {
        return f(a, function(a) {
            var b = 0,
                c = l();
            E(a, function(d, e, g) {
                var h;
                p(e) && "fulfilled" === (h = e.inspect()).state ? a[g] = h.value : (++b, f(e, function(d) {
                    a[g] = d;
                    0 === --b && c.resolve(a)
                }, c.reject, function(a) {
                    c.notify({
                        index: g,
                        value: a
                    })
                }))
            }, void 0);
            0 === b && c.resolve(a);
            return c.promise
        })
    }

    function B(a) {
        return f(a,
            function(a) {
                a = I(a, b);
                return f(x(I(a, function(a) {
                    return f(a, N, N)
                })), function() {
                    return a
                })
            })
    }
    var z = !1;
    try {
        throw Error();
    } catch (G) {
        z = !!G.stack
    }
    var O = k(),
        M, N = function() {},
        w = function() {
            function a() {
                for (; b.next;) {
                    b = b.next;
                    var c = b.task;
                    b.task = void 0;
                    var e = b.domain;
                    e && (b.domain = void 0, e.enter());
                    try {
                        c()
                    } catch (g) {
                        if (f) throw e && e.exit(), setTimeout(a, 0), e && e.enter(), g;
                        setTimeout(function() {
                            throw g;
                        }, 0)
                    }
                    e && e.exit()
                }
                d = !1
            }
            var b = {
                    task: void 0,
                    next: null
                },
                c = b,
                d = !1,
                e = void 0,
                f = !1;
            w = function(a) {
                c = c.next = {
                    task: a,
                    domain: f &&
                    process.domain,
                    next: null
                };
                d || (d = !0, e())
            };
            if ("undefined" !== typeof process && process.nextTick) f = !0, e = function() {
                process.nextTick(a)
            };
            else if ("function" === typeof setImmediate) e = "undefined" !== typeof window ? setImmediate.bind(window, a) : function() {
                setImmediate(a)
            };
            else if ("undefined" !== typeof MessageChannel) {
                var g = new MessageChannel;
                g.port1.onmessage = function() {
                    e = h;
                    g.port1.onmessage = a;
                    a()
                };
                var h = function() {
                        g.port2.postMessage(0)
                    },
                    e = function() {
                        setTimeout(a, 0);
                        h()
                    }
            } else e = function() {
                setTimeout(a, 0)
            };
            return w
        }(),
        P = Function.call,
        u = d(Array.prototype.slice),
        E = d(Array.prototype.reduce || function(a, b) {
            var c = 0,
                d = this.length;
            if (1 === arguments.length) {
                do {
                    if (c in this) {
                        b = this[c++];
                        break
                    }
                    if (++c >= d) throw new TypeError;
                } while (1)
            }
            for (; c < d; c++) c in this && (b = a(b, this[c], c));
            return b
        }),
        S = d(Array.prototype.indexOf || function(a) {
            for (var b = 0; b < this.length; b++)
                if (this[b] === a) return b;
            return -1
        }),
        I = d(Array.prototype.map || function(a, b) {
            var c = this,
                d = [];
            E(c, function(e, f, g) {
                d.push(a.call(b, f, g, c))
            }, void 0);
            return d
        }),
        H = Object.create ||
            function(a) {
                function b() {}
                b.prototype = a;
                return new b
            },
        U = d(Object.prototype.hasOwnProperty),
        T = Object.keys || function(a) {
                var b = [],
                    c;
                for (c in a) U(a, c) && b.push(c);
                return b
            },
        V = d(Object.prototype.toString),
        J;
    J = "undefined" !== typeof ReturnValue ? ReturnValue : function(a) {
        this.value = a
    };
    b.resolve = b;
    b.nextTick = w;
    b.longStackSupport = !1;
    b.defer = l;
    l.prototype.makeNodeResolver = function() {
        var a = this;
        return function(b, c) {
            b ? a.reject(b) : 2 < arguments.length ? a.resolve(u(arguments, 1)) : a.resolve(c)
        }
    };
    b.Promise = a;
    b.promise = a;
    a.race = c;
    a.all = x;
    a.reject = q;
    a.resolve = b;
    b.passByCopy = function(a) {
        return a
    };
    e.prototype.passByCopy = function() {
        return this
    };
    b.join = function(a, c) {
        return b(a).join(c)
    };
    e.prototype.join = function(a) {
        return b([this, a]).spread(function(a, b) {
            if (a === b) return a;
            throw Error("Can't join: not the same: " + a + " " + b);
        })
    };
    b.race = c;
    e.prototype.race = function() {
        return this.then(b.race)
    };
    b.makePromise = e;
    e.prototype.toString = function() {
        return "[object Promise]"
    };
    e.prototype.then = function(a, c, d) {
        function e(b) {
            try {
                return "function" ===
                typeof a ? a(b) : b
            } catch (c) {
                return q(c)
            }
        }

        function f(a) {
            if ("function" === typeof c) {
                g(a, h);
                try {
                    return c(a)
                } catch (b) {
                    return q(b)
                }
            }
            return q(a)
        }
        var h = this,
            k = l(),
            t = !1;
        w(function() {
            h.promiseDispatch(function(a) {
                t || (t = !0, k.resolve(e(a)))
            }, "when", [
                function(a) {
                    t || (t = !0, k.resolve(f(a)))
                }
            ])
        });
        h.promiseDispatch(void 0, "when", [void 0,
            function(a) {
                var c, e = !1;
                try {
                    c = "function" === typeof d ? d(a) : a
                } catch (f) {
                    if (e = !0, b.onerror) b.onerror(f);
                    else throw f;
                }
                e || k.notify(c)
            }
        ]);
        return k.promise
    };
    b.when = f;
    e.prototype.thenResolve = function(a) {
        return this.then(function() {
            return a
        })
    };
    b.thenResolve = function(a, c) {
        return b(a).thenResolve(c)
    };
    e.prototype.thenReject = function(a) {
        return this.then(function() {
            throw a;
        })
    };
    b.thenReject = function(a, c) {
        return b(a).thenReject(c)
    };
    b.nearer = m;
    b.isPromise = p;
    b.isPromiseAlike = v;
    b.isPending = function(a) {
        return p(a) && "pending" === a.inspect().state
    };
    e.prototype.isPending = function() {
        return "pending" === this.inspect().state
    };
    b.isFulfilled = function(a) {
        return !p(a) || "fulfilled" === a.inspect().state
    };
    e.prototype.isFulfilled = function() {
        return "fulfilled" === this.inspect().state
    };
    b.isRejected = function(a) {
        return p(a) && "rejected" === a.inspect().state
    };
    e.prototype.isRejected = function() {
        return "rejected" === this.inspect().state
    };
    var C = [],
        F = [],
        D = !0;
    b.resetUnhandledRejections = r;
    b.getUnhandledReasons = function() {
        return C.slice()
    };
    b.stopUnhandledRejectionTracking = function() {
        r();
        D = !1
    };
    r();
    b.reject = q;
    b.fulfill = t;
    b.master = function(a) {
        return e({
            isDef: function() {}
        }, function(b, c) {
            return A(a, b, c)
        }, function() {
            return b(a).inspect()
        })
    };
    b.spread = K;
    e.prototype.spread = function(a, b) {
        return this.all().then(function(b) {
            return a.apply(void 0,
                b)
        }, b)
    };
    b.async = function(a) {
        return function() {
            function b(a, g) {
                var h;
                if ("undefined" === typeof StopIteration) {
                    try {
                        h = c[a](g)
                    } catch (k) {
                        return q(k)
                    }
                    return h.done ? h.value : f(h.value, d, e)
                }
                try {
                    h = c[a](g)
                } catch (l) {
                    return "[object StopIteration]" === V(l) || l instanceof J ? l.value : q(l)
                }
                return f(h, d, e)
            }
            var c = a.apply(this, arguments),
                d = b.bind(b, "next"),
                e = b.bind(b, "throw");
            return d()
        }
    };
    b.spawn = function(a) {
        b.done(b.async(a)())
    };
    b["return"] = function(a) {
        throw new J(a);
    };
    b.promised = function(a) {
        return function() {
            return K([this,
                x(arguments)
            ], function(b, c) {
                return a.apply(b, c)
            })
        }
    };
    b.dispatch = A;
    e.prototype.dispatch = function(a, b) {
        var c = this,
            d = l();
        w(function() {
            c.promiseDispatch(d.resolve, a, b)
        });
        return d.promise
    };
    b.get = function(a, c) {
        return b(a).dispatch("get", [c])
    };
    e.prototype.get = function(a) {
        return this.dispatch("get", [a])
    };
    b.set = function(a, c, d) {
        return b(a).dispatch("set", [c, d])
    };
    e.prototype.set = function(a, b) {
        return this.dispatch("set", [a, b])
    };
    b.del = b["delete"] = function(a, c) {
        return b(a).dispatch("delete", [c])
    };
    e.prototype.del =
        e.prototype["delete"] = function(a) {
            return this.dispatch("delete", [a])
        };
    b.mapply = b.post = function(a, c, d) {
        return b(a).dispatch("post", [c, d])
    };
    e.prototype.mapply = e.prototype.post = function(a, b) {
        return this.dispatch("post", [a, b])
    };
    b.send = b.mcall = b.invoke = function(a, c) {
        return b(a).dispatch("post", [c, u(arguments, 2)])
    };
    e.prototype.send = e.prototype.mcall = e.prototype.invoke = function(a) {
        return this.dispatch("post", [a, u(arguments, 1)])
    };
    b.fapply = function(a, c) {
        return b(a).dispatch("apply", [void 0, c])
    };
    e.prototype.fapply =
        function(a) {
            return this.dispatch("apply", [void 0, a])
        };
    b["try"] = b.fcall = function(a) {
        return b(a).dispatch("apply", [void 0, u(arguments, 1)])
    };
    e.prototype.fcall = function() {
        return this.dispatch("apply", [void 0, u(arguments)])
    };
    b.fbind = function(a) {
        var c = b(a),
            d = u(arguments, 1);
        return function() {
            return c.dispatch("apply", [this, d.concat(u(arguments))])
        }
    };
    e.prototype.fbind = function() {
        var a = this,
            b = u(arguments);
        return function() {
            return a.dispatch("apply", [this, b.concat(u(arguments))])
        }
    };
    b.keys = function(a) {
        return b(a).dispatch("keys", [])
    };
    e.prototype.keys = function() {
        return this.dispatch("keys", [])
    };
    b.all = x;
    e.prototype.all = function() {
        return x(this)
    };
    b.allResolved = function(a, b, c) {
        return function() {
            "undefined" !== typeof console && "function" === typeof console.warn && console.warn(b + " is deprecated, use " + c + " instead.", Error("").stack);
            return a.apply(a, arguments)
        }
    }(B, "allResolved", "allSettled");
    e.prototype.allResolved = function() {
        return B(this)
    };
    b.allSettled = function(a) {
        return b(a).allSettled()
    };
    e.prototype.allSettled = function() {
        return this.then(function(a) {
            return x(I(a,
                function(a) {
                    function c() {
                        return a.inspect()
                    }
                    a = b(a);
                    return a.then(c, c)
                }))
        })
    };
    b.fail = b["catch"] = function(a, c) {
        return b(a).then(void 0, c)
    };
    e.prototype.fail = e.prototype["catch"] = function(a) {
        return this.then(void 0, a)
    };
    b.progress = function(a, c) {
        return b(a).then(void 0, void 0, c)
    };
    e.prototype.progress = function(a) {
        return this.then(void 0, void 0, a)
    };
    b.fin = b["finally"] = function(a, c) {
        return b(a)["finally"](c)
    };
    e.prototype.fin = e.prototype["finally"] = function(a) {
        a = b(a);
        return this.then(function(b) {
                return a.fcall().then(function() {
                    return b
                })
            },
            function(b) {
                return a.fcall().then(function() {
                    throw b;
                })
            })
    };
    b.done = function(a, c, d, e) {
        return b(a).done(c, d, e)
    };
    e.prototype.done = function(a, c, d) {
        var e = function(a) {
                w(function() {
                    g(a, f);
                    if (b.onerror) b.onerror(a);
                    else throw a;
                })
            },
            f = a || c || d ? this.then(a, c, d) : this;
        "object" === typeof process && process && process.domain && (e = process.domain.bind(e));
        f.then(void 0, e)
    };
    b.timeout = function(a, c, d) {
        return b(a).timeout(c, d)
    };
    e.prototype.timeout = function(a, b) {
        var c = l(),
            d = setTimeout(function() {
                c.reject(Error(b || "Timed out after " +
                a + " ms"))
            }, a);
        this.then(function(a) {
            clearTimeout(d);
            c.resolve(a)
        }, function(a) {
            clearTimeout(d);
            c.reject(a)
        }, c.notify);
        return c.promise
    };
    b.delay = function(a, c) {
        void 0 === c && (c = a, a = void 0);
        return b(a).delay(c)
    };
    e.prototype.delay = function(a) {
        return this.then(function(b) {
            var c = l();
            setTimeout(function() {
                c.resolve(b)
            }, a);
            return c.promise
        })
    };
    b.nfapply = function(a, c) {
        return b(a).nfapply(c)
    };
    e.prototype.nfapply = function(a) {
        var b = l();
        a = u(a);
        a.push(b.makeNodeResolver());
        this.fapply(a).fail(b.reject);
        return b.promise
    };
    b.nfcall = function(a) {
        var c = u(arguments, 1);
        return b(a).nfapply(c)
    };
    e.prototype.nfcall = function() {
        var a = u(arguments),
            b = l();
        a.push(b.makeNodeResolver());
        this.fapply(a).fail(b.reject);
        return b.promise
    };
    b.nfbind = b.denodeify = function(a) {
        var c = u(arguments, 1);
        return function() {
            var d = c.concat(u(arguments)),
                e = l();
            d.push(e.makeNodeResolver());
            b(a).fapply(d).fail(e.reject);
            return e.promise
        }
    };
    e.prototype.nfbind = e.prototype.denodeify = function() {
        var a = u(arguments);
        a.unshift(this);
        return b.denodeify.apply(void 0,
            a)
    };
    b.nbind = function(a, c) {
        var d = u(arguments, 2);
        return function() {
            var e = d.concat(u(arguments)),
                f = l();
            e.push(f.makeNodeResolver());
            b(function() {
                return a.apply(c, arguments)
            }).fapply(e).fail(f.reject);
            return f.promise
        }
    };
    e.prototype.nbind = function() {
        var a = u(arguments, 0);
        a.unshift(this);
        return b.nbind.apply(void 0, a)
    };
    b.nmapply = b.npost = function(a, c, d) {
        return b(a).npost(c, d)
    };
    e.prototype.nmapply = e.prototype.npost = function(a, b) {
        var c = u(b || []),
            d = l();
        c.push(d.makeNodeResolver());
        this.dispatch("post", [a, c]).fail(d.reject);
        return d.promise
    };
    b.nsend = b.nmcall = b.ninvoke = function(a, c) {
        var d = u(arguments, 2),
            e = l();
        d.push(e.makeNodeResolver());
        b(a).dispatch("post", [c, d]).fail(e.reject);
        return e.promise
    };
    e.prototype.nsend = e.prototype.nmcall = e.prototype.ninvoke = function(a) {
        var b = u(arguments, 1),
            c = l();
        b.push(c.makeNodeResolver());
        this.dispatch("post", [a, b]).fail(c.reject);
        return c.promise
    };
    b.nodeify = function(a, c) {
        return b(a).nodeify(c)
    };
    e.prototype.nodeify = function(a) {
        if (a) this.then(function(b) {
            w(function() {
                a(null, b)
            })
        }, function(b) {
            w(function() {
                a(b)
            })
        });
        else return this
    };
    var R = k();
    return b
});
(function(d, g) {
    "object" == typeof exports ? module.exports = g() : "function" == typeof define && define.amd ? define(g) : d.Spinner = g()
})(
    this, function() {
    function d(a, b) {
        var c = document.createElement(a || "div"),
            d;
        for (d in b) c[d] = b[d];
        return c
    }

    function g(a) {
        for (var b = 1, c = arguments.length; b < c; b++) a.appendChild(arguments[b]);
        return a
    }

    function h(a, b, c, d) {
        var e = ["opacity", b, ~~(100 * a), c, d].join("-");
        c = .01 + c / d * 100;
        d = Math.max(1 - (1 - a) / b * (100 - c), a);
        var f = p.substring(0, p.indexOf("Animation")).toLowerCase();
        m[e] || (v.insertRule("@" +
        (f && "-" + f + "-" || "") + "keyframes " + e + "{0%{opacity:" + d + "}" + c + "%{opacity:" + a + "}" + (c + .01) + "%{opacity:1}" + (c + b) % 100 + "%{opacity:" + a + "}100%{opacity:" + d + "}}", v.cssRules.length), m[e] = 1);
        return e
    }

    function k(a, b) {
        var c = a.style,
            d, e;
        b = b.charAt(0).toUpperCase() + b.slice(1);
        for (e = 0; e < f.length; e++)
            if (d = f[e] + b, void 0 !== c[d]) return d;
        if (void 0 !== c[b]) return b
    }

    function b(a, b) {
        for (var c in b) a.style[k(a, c) || c] = b[c];
        return a
    }

    function l(a) {
        for (var b = 1; b < arguments.length; b++) {
            var c = arguments[b],
                d;
            for (d in c) void 0 === a[d] &&
            (a[d] = c[d])
        }
        return a
    }

    function a(a, b) {
        return "string" == typeof a ? a : a[b % a.length]
    }

    function c(a) {
        this.opts = l(a || {}, c.defaults, r)
    }

    function e() {
        function e(a, b) {
            return d("<" + a + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', b)
        }
        v.addRule(".spin-vml", "behavior:url(#default#VML)");
        c.prototype.lines = function(c, d) {
            function f() {
                return b(e("group", {
                    coordsize: l + " " + l,
                    coordorigin: -k + " " + -k
                }), {
                    width: l,
                    height: l
                })
            }

            function h(c, l, m) {
                g(n, g(b(f(), {
                    rotation: 360 / d.lines * c + "deg",
                    left: ~~l
                }), g(b(e("roundrect", {
                    arcsize: d.corners
                }), {
                    width: k,
                    height: d.width,
                    left: d.radius,
                    top: -d.width >> 1,
                    filter: m
                }), e("fill", {
                    color: a(d.color, c),
                    opacity: d.opacity
                }), e("stroke", {
                    opacity: 0
                }))))
            }
            var k = d.length + d.width,
                l = 2 * k,
                m = 2 * -(d.width + d.length) + "px",
                n = b(f(), {
                    position: "absolute",
                    top: m,
                    left: m
                });
            if (d.shadow)
                for (m = 1; m <= d.lines; m++) h(m, -2, "progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)");
            for (m = 1; m <= d.lines; m++) h(m);
            return g(c, n)
        };
        c.prototype.opacity = function(a, b, c, d) {
            a = a.firstChild;
            d = d.shadow && d.lines || 0;
            a && b + d < a.childNodes.length &&
            (a = (a = (a = a.childNodes[b + d]) && a.firstChild) && a.firstChild) && (a.opacity = c)
        }
    }
    var f = ["webkit", "Moz", "ms", "O"],
        m = {},
        p, v = function() {
            var a = d("style", {
                type: "text/css"
            });
            g(document.getElementsByTagName("head")[0], a);
            return a.sheet || a.styleSheet
        }(),
        r = {
            lines: 12,
            length: 7,
            width: 5,
            radius: 10,
            rotate: 0,
            corners: 1,
            color: "#000",
            direction: 1,
            speed: 1,
            trail: 100,
            opacity: .25,
            fps: 20,
            zIndex: 2E9,
            className: "spinner",
            top: "50%",
            left: "50%",
            position: "absolute"
        };
    c.defaults = {};
    l(c.prototype, {
        spin: function(a) {
            this.stop();
            var c = this,
                e = c.opts,
                f = c.el = b(d(0, {
                    className: e.className
                }), {
                    position: e.position,
                    width: 0,
                    zIndex: e.zIndex
                });
            b(f, {
                left: e.left,
                top: e.top
            });
            a && a.insertBefore(f, a.firstChild || null);
            f.setAttribute("role", "progressbar");
            c.lines(f, c.opts);
            if (!p) {
                var g = 0,
                    h = (e.lines - 1) * (1 - e.direction) / 2,
                    k, l = e.fps,
                    m = l / e.speed,
                    n = (1 - e.opacity) / (m * e.trail / 100),
                    r = m / e.lines;
                (function w() {
                    g++;
                    for (var a = 0; a < e.lines; a++) k = Math.max(1 - (g + (e.lines - a) * r) % m * n, e.opacity), c.opacity(f, a * e.direction + h, k, e);
                    c.timeout = c.el && setTimeout(w, ~~(1E3 / l))
                })()
            }
            return c
        },
        stop: function() {
            var a = this.el;
            a && (clearTimeout(this.timeout), a.parentNode && a.parentNode.removeChild(a), this.el = void 0);
            return this
        },
        lines: function(c, e) {
            function f(a, c) {
                return b(d(), {
                    position: "absolute",
                    width: e.length + e.width + "px",
                    height: e.width + "px",
                    background: a,
                    boxShadow: c,
                    transformOrigin: "left",
                    transform: "rotate(" + ~~(360 / e.lines * k + e.rotate) + "deg) translate(" + e.radius + "px,0)",
                    borderRadius: (e.corners * e.width >> 1) + "px"
                })
            }
            for (var k = 0, l = (e.lines - 1) * (1 - e.direction) / 2, m; k < e.lines; k++) m = b(d(), {
                position: "absolute",
                top: 1 + ~(e.width / 2) + "px",
                transform: e.hwaccel ? "translate3d(0,0,0)" : "",
                opacity: e.opacity,
                animation: p && h(e.opacity, e.trail, l + k * e.direction, e.lines) + " " + 1 / e.speed + "s linear infinite"
            }), e.shadow && g(m, b(f("#000", "0 0 4px #000"), {
                top: "2px"
            })), g(c, g(m, f(a(e.color, k), "0 0 1px rgba(0,0,0,.1)")));
            return c
        },
        opacity: function(a, b, c) {
            b < a.childNodes.length && (a.childNodes[b].style.opacity = c)
        }
    });
    var n = b(d("group"), {
        behavior: "url(#default#VML)"
    });
    !k(n, "transform") && n.adj ? e() : p = k(n, "animation");
    return c
});
(
    function() {
    var d, g;
    g = window.NGR;
    d = L.noConflict();
    "object" === typeof module && "object" === typeof module.exports ? module.exports = d : "function" === typeof define && define(d);
    d.noConflict = function() {
        window.NGR = g;
        return this
    };
    window.NGR = d;
    d._coreMap = d.Map.extend({
        initialize: function(g, k) {
            d.Map.prototype.initialize.call(this, g, k);
            this.featureLayers = [];
            this.mainBounds = d.latLngBounds([]);
            return this.on("zoomend", function() {
                return this.zoomDelta = this.getZoom() - this.initZoomLvl | 0
            }, this)
        },
        addFeatureLayer: function(g) {
            d.Map.prototype.addLayer.call(this,
                g);
            this.mainBounds.extend(g.getBounds());
            this.fixedPointOnMap || (this._meterPixelRatio = null, this._fixedPointOnMap = g.getBounds().getCenter(), this._fixedPointOnMapOffsetOneMeter = d.CRS.EPSG3857.unproject(d.CRS.EPSG3857.project(this._fixedPointOnMap).add([1, 1])));
            return this.featureLayers.push(g)
        },
        removeFeatureLayer: function(g) {
            d.Map.prototype.removeLayer.call(this, g);
            return this.featureLayers.slice(this.featureLayers.indexOf(g), 1)
        },
        render: function() {
            d.Cache.mainPromise.then(function(d) {
                return function() {
                    d.fitBounds(d.mainBounds);
                    return d.initZoomLvl = d.getZoom()
                }
            }(this));
            return this
        },
        clear: function() {
            var g, k, b;
            b = this._layers;
            for (g in b) k = b[g], this.removeLayer(k);
            this.featureLayers.length = 0;
            this.fixedPointOnMap = this.initZoomLvl = null;
            return this.mainBounds = d.latLngBounds([])
        },
        setMinZoom: function(d) {
            this.options.minZoom = d;
            return this
        },
        setMaxZoom: function(d) {
            this.options.maxZoom = d;
            return this
        }
    })
}).call(this);
(
    function() {
    NGR.Cache = {};
    NGR.Cache.mainPromise = Q.all([]);
    NGR.Cache._imageCache = {};
    NGR.Cache._patternCache = {};
    NGR.Cache.loadImages = function(d) {
        var g;
        return NGR.Cache.mainPromise = Q.all(function() {
            var h, k, b;
            b = [];
            h = 0;
            for (k = d.length; h < k; h++) g = d[h], b.push(NGR.Cache._loadImage(g));
            return b
        }())
    };
    NGR.Cache._loadImage = function(d, g) {
        var h, k;
        h = Q.defer();
        name in NGR.Cache._imageCache && h.resolve(NGR.Cache._imageCache[d]);
        k = new Image;
        k.addEventListener("load", function() {
            return h.resolve(NGR.Cache._imageCache[d] =
                k)
        });
        k.addEventListener("error", function() {
            console.error("Error loading " + d);
            return h.reject()
        });
        k.src = d;
        return h.promise.nodeify(g)
    }
}).call(this);
(
    function() {
    NGR.IO = {};
    NGR.IO.fetch = function(d, g) {
        var h, k, b, l, a, c, e, f, m, p;
        h = d.data;
        f = d.url;
        l = d.header;
        e = d.onsuccess;
        c = d.onerror;
        k = Q.defer();
        p = new window.XMLHttpRequest;
        h && (f += "?" + function() {
            var b;
            b = [];
            for (a in h) m = h[a], b.push("" + encodeURIComponent(a) + "=" + encodeURIComponent(m));
            return b
        }().join("&"));
        p.addEventListener("progress", function(a) {
            return a.lengthComputable ? k.notify({
                predictable: !0,
                percentage: a.loaded / a.total,
                loaded: a.loaded
            }) : k.notify({
                predictable: !1,
                loaded: a.loaded
            })
        }, !1);
        p.addEventListener("load",
            function() {
                if (this.readyState === this.DONE && 200 === this.status) return k.resolve(e ? e(this.responseText) : this.responseText);
                c && c(this.readyState, this.status);
                return k.reject(this.readyState, this.status)
            }, !1);
        p.addEventListener("error", function() {
            c && c(this.readyState, this.status);
            return k.reject(this.readyState, this.status)
        }, !1);
        p.addEventListener("abort", function() {
            c && c(this.readyState, this.status);
            return k.reject(this.readyState, this.status)
        }, !1);
        p.open("GET", f, !0);
        for (b in l) f = l[b], p.setRequestHeader(b,
            f);
        p.send();
        return k.promise.nodeify(g)
    }
}).call(this);
(
    function() {
    NGR.DataSource = function(d) {
        null == d && (d = {});
        this._server = d.server || "http://api.ipalmap.com/";
        this._header = d.header || {
            Accept: "application/json"
        }
    };
    NGR.DataSource.prototype.requestRegions = function(d, g) {
        null == d && (d = "CN");
        return NGR.IO.fetch({
            url: "" + this._server + "administrative_unit_tree/" + d,
            onsuccess: JSON.parse,
            header: this._header
        }).nodeify(g)
    };
    NGR.DataSource.prototype.requestMaps = function(d, g) {
        return NGR.IO.fetch({
            data: d,
            url: "" + this._server + "map/list",
            onsuccess: JSON.parse,
            header: this._header
        }).nodeify(g)
    };
    NGR.DataSource.prototype.requestFloors = function(d, g) {
        return NGR.IO.fetch({
            url: "" + this._server + "floor/list/map/" + d,
            onsuccess: JSON.parse,
            header: this._header
        }).nodeify(g)
    };
    NGR.DataSource.prototype.requestShops = function(d, g, h) {
        null == g && (g = 0);
        return NGR.IO.fetch({
            data: {
                start: g,
                url: "" + this._server + "shop/list/floor/" + d,
                onsuccess: JSON.parse,
                header: this._header
            }
        }).nodeify(h)
    };
    NGR.DataSource.prototype.requestPlanarGraph = function(d, g, h) {
        null == g && (g = ["frame", "shop", "publicService"]);
        //d = "" + this._server + "floor/mapdata/" +
        //d;
        d="tuju.txt"
        g = {
            layer_list: JSON.stringify(g)
        };
        return NGR.IO.fetch({
            data: g,
            url: d,
            onsuccess: JSON.parse,
            header: this._header
        }).nodeify(h)
    };
    NGR.DataSource.prototype.requestCategories = function(d, g, h, k) {
        null == h && (h = 3);
        return NGR.IO.fetch({
            data: {
                down_to_bottom_cat_level: h
            },
            url: "" + this._server + "category/list/" + d + "/" + g,
            onsuccess: JSON.parse,
            header: this._header
        }).nodeify(k)
    };
    NGR.DataSource.requestPOIDetail = function(d, g) {
        return NGR.IO.fetch({
            url: "" + this._server + "poi/detail" + d,
            onsuccess: JSON.parse,
            header: this._header
        }).nodeify(g)
    };
    NGR.DataSource.POISearch = function(d, g) {
        var h, k, b;
        k = "" + this._server + "poi/search";
        for (h in d) b = d[h], "word" !== h && "start" !== h && (d[h] = JSON.stringify(b));
        return NGR.IO.fetch({
            data: d,
            url: k,
            onsuccess: JSON.parse,
            header: this._header
        }).nodeify(g)
    }
}).call(this);
(function() {
    NGR.View = function(d, g) {
        document.getElementById(d) && (this._core_map = new NGR._coreMap(d, g))
    };
    NGR.View.prototype.on = function(d, g, h) {
        return this._core_map.on(d, g, h)
    };
    NGR.View.prototype.off = function(d, g, h) {
        return this._core_map.off(d, g, h)
    };
    NGR.View.prototype.setView = function(d, g) {
        return this._core_map.setView(d, g)
    };
    NGR.View.prototype.setZoom = function(d) {
        return this._core_map.setZoom(d)
    };
    NGR.View.prototype.zoomIn = function(d) {
        null == d && (d = 1);
        return this._core_map.zoomIn(d)
    };
    NGR.View.prototype.zoomOut =
        function(d) {
            null == d && (d = 1);
            return this._core_map.zoomOut(d)
        };
    NGR.View.prototype.setZoomAround = function(d, g, h) {
        return this._core_map.setZoomAround(d, g, h)
    };
    NGR.View.prototype.fitBounds = function(d) {
        return this._core_map.fitBounds(d)
    };
    NGR.View.prototype.panTo = function(d, g) {
        return this._core_map.panTo(d, g)
    };
    NGR.View.prototype.panInsideBounds = function(d, g) {
        return this._core_map.panInsideBounds(d, g)
    };
    NGR.View.prototype.panBy = function(d, g) {
        return this._core_map.panBy(d, g)
    };
    NGR.View.prototype.setMaxBounds =
        function(d) {
            return this._core_map.setMaxBounds(d)
        };
    NGR.View.prototype.setMinZoom = function(d) {
        return this._core_map.setMinZoom(d)
    };
    NGR.View.prototype.setMaxZoom = function(d) {
        return this._core_map.setMaxZoom(d)
    };
    NGR.View.prototype.remove = function() {
        return this._core_map.remove()
    };
    NGR.View.prototype.getCenter = function() {
        return this._core_map.getCenter()
    };
    NGR.View.prototype.getZoom = function() {
        return this._core_map.getZoom()
    };
    NGR.View.prototype.getMinZoom = function() {
        return this._core_map.getMinZoom()
    };
    NGR.View.prototype.getMaxZoom = function() {
        return this._core_map.getMaxZoom()
    };
    NGR.View.prototype.getBounds = function() {
        return this._core_map.getBounds()
    };
    NGR.View.prototype.getBoundsZoom = function(d, g) {
        return this._core_map.getBoundsZoom(d, g)
    };
    NGR.View.prototype.getSize = function() {
        return this._core_map.getSize()
    };
    NGR.View.prototype.addLayer = function(d) {
        return d instanceof NGR.FeatureLayer ? this._core_map.addFeatureLayer(d) : this._core_map.addLayer(d)
    };
    NGR.View.prototype.removeLayer = function(d) {
        return d instanceof
        NGR.FeatureLayer ? this._core_map.removeFeatureLayer(d) : this._core_map.removeLayer(d)
    };
    NGR.View.prototype.hasLayer = function(d) {
        return this._core_map.hasLayer(d)
    };
    NGR.View.prototype.eachLayer = function(d, g) {
        return this._core_map.eachLayer(d, g)
    };
    NGR.View.prototype.openPopup = function(d) {
        return this._core_map.openPopup(d)
    };
    NGR.View.prototype.closePopup = function(d) {
        return this._core_map.closePopup(d)
    };
    NGR.View.prototype.addControl = function(d) {
        return this._core_map.addControl(d)
    };
    NGR.View.prototype.removeControl =
        function(d) {
            return this._core_map.removeControl(d)
        };
    NGR.View.prototype.latLngToContainerPoint = function(d) {
        return this._core_map.latLngToContainerPoint(d)
    };
    NGR.View.prototype.containerPointToLatLng = function(d) {
        return this._core_map.containerPointToLatLng(d)
    };
    NGR.View.prototype.mouseEventToContainerPoint = function(d) {
        return this._core_map.mouseEventToContainerPoint(d)
    };
    NGR.View.prototype.mouseEventToLatLng = function(d) {
        return this._core_map.mouseEventToLatLng(d)
    };
    NGR.View.prototype.getContainer = function() {
        return this._core_map.getContainer()
    };
    NGR.View.prototype.addFeatureLayer = function(d) {
        this._core_map.addFeatureLayer(d);
        return this
    };
    NGR.View.prototype.removeFeatureLayer = function(d) {
        this._core_map.removeFeatureLayer(d);
        return this
    };
    NGR.View.prototype.render = function() {
        this._core_map.render();
        return this
    };
    NGR.View.prototype.clear = function() {
        this._core_map.clear();
        return this
    };
    NGR.View.CRS = NGR.CRS.EPSG3857;
    NGR.view = function(d, g) {
        return new NGR.View(d, g)
    }
}).call(this);
(function() {
    NGR.FeatureLayer = NGR.GeoJSON.extend({
        options: {
            styleConfig: {}
        },
        initialize: function(d, g) {
            var h;
            NGR.setOptions(this, g);
            this._layers = {};
            d.featureCollection ? (h = d.featureCollection.features, this.layer_type = this.options.layer_type || d.layer_type) : (h = d, this.layer_type = this.options.layer_type || "default");
            this._featureLayers = {};
            this._featureLabels = {};
            this._prefetchTexture();
            h && this.addData(h)
        },
        onAdd: function(d) {
            NGR.GeoJSON.prototype.onAdd.call(this, d);
            return this
        },
        _prefetchTexture: function() {
            var d,
                g, h, k, b, l, a;
            k = [];
            if (this.layer_type in this.options.styleConfig) {
                g = this.options.styleConfig[this.layer_type];
                d = g.common;
                g = g.filter;
                "texture" in d.style && k.push(d.style.texture.url);
                if (g)
                    for (d = 0, l = g.length; d < l; d++)
                        for (b in h = g[d], a = h.values, a) h = a[b], "texture" in h && k.push(h.texture.url);
                if (0 < k.length) return NGR.Cache.loadImages(k)
            }
        },
        _template: function(d, g) {
            var h;
            if ("[object String]" !== Object.prototype.toString.call(g)) return g;
            h = g.replace(/%(\S*?)%/g, function(d, b) {
                return eval("this.properties." + b)
            }.bind(d));
            return "null" === h ? null : h
        },
        _parseStyle: function(d, g, h) {
            var k, b, l, a;
            h.mainStyle || (h.mainStyle = {});
            for (l in g) switch (a = g[l], l) {
                case "label":
                    h.labelStyle || (h.labelStyle = {});
                    for (k in a) b = a[k], h.labelStyle[k] = this._template(d, b);
                    break;
                case "texture":
                    h.mainStyle.texture = a.url;
                    h.mainStyle.textureSize = a.size;
                    h.mainStyle.textureRotate = a.rotate;
                    break;
                default:
                    h.mainStyle[l] = this._template(d, a)
            }
        },
        resetStyle: function(d) {
            NGR.Util.extend(d.options, d.defaultOptions);
            return this._setLayerStyle(d, this.options.style)
        },
        configStyle: function(d) {
            var g, h, k, b, l, a, c, e;
            if (!(this.options.styleConfig && this.layer_type in this.options.styleConfig)) return {};
            l = {};
            h = this.options.styleConfig[this.layer_type];
            a = h.type;
            g = h.common;
            h = h.filter;
            a && "inherit" !== a && (l.preparedType = a);
            this._parseStyle(d, g.style, l);
            c = h || [];
            a = 0;
            for (h = c.length; a < h; a++)
                if (k = c[a], g = eval("arguments[0].properties." + k.property))
                    for (b in e = k.values, e) k = e[b], g == b && this._parseStyle(d, k, l);
            return l
        },
        addData: function(d) {
            var g, h, k;
            if (h = NGR.Util.isArray(d) ? d : d.features) {
                d =
                    0;
                for (k = h.length; d < k; d++) g = h[d], (g.geometries || g.geometry || g.features || g.coordinates) && this.addData(g);
                return this
            }
            if (!this.options.filter || this.options.filter(d)) {
                h = this.geometryToLayer(d, this.options.pointToLayer, this.options.coordsToLatLng, this.options);
                h.feature = NGR.GeoJSON.asFeature(d);
                this._featureLayers[h.feature.properties.id] = h;
                h.defaultOptions = h.options;
                this.resetStyle(h);
                if (this.options.onEachFeature) this.options.onEachFeature(d, h);
                this.addLayer(h);
                d = this._featureLabels;
                k = [];
                for (g in d) h =
                    d[g], k.push(this.addLayer(h));
                return k
            }
        },
        addFeature: function(d) {
            return this.addData(d)
        },
        removeFeature: function(d) {
            d = d.properties.id;
            d in this._featureLayers && (this.removeLayer(this._featureLayers[d]), delete this._featureLayers[d]);
            if (d in this._featureLabels) return this.removeLayer(this._featureLabels[d]), delete this._featureLabels[d]
        },
        getLayerByFeatureId: function(d) {
            return this._featureLayers[d]
        },
        getLabelByFeatureId: function(d) {
            return this._featureLabels[d]
        },
        clearLayers: function() {
            NGR.GeoJSON.prototype.clearLayers.call(this);
            this._featureLabels = {};
            return this._featureLayers = {}
        },
        getBounds: function() {
            var d;
            d = new NGR.LatLngBounds;
            this.eachLayer(function(g) {
                return d.extend(g instanceof NGR.Marker || g instanceof NGR.CanvasLabel || g instanceof NGR.Circle || g instanceof NGR.CanvasMarker ? g.getLatLng() : g.getBounds())
            });
            return d
        },
        geometryToLayer: function(d, g, h) {
            var k, b, l, a, c;
            l = "Feature" === d.type ? d.geometry : d;
            b = l.coordinates;
            a = this.configStyle(d);
            h = h || this.coordsToLatLng;
            switch (a.preparedType || l.type) {
                case "Point":
                    return h = h(b), g ?
                        g(d, h) : NGR.circle(h, a.mainStyle.radius || .8);
                case "MultiPoint":
                    a = [];
                    l = 0;
                    for (c = b.length; l < c; l++) k = b[l], k = h(k), a.push(g ? g(d, k) : new NGR.Marker(k));
                    return new NGR.FeatureGroup(a);
                case "LineString":
                    return g = this.coordsToLatLngs(b, 0, h), NGR.polyline(g, a.mainStyle);
                case "Polygon":
                    if (2 === b.length && !b[1].length) throw "Invalid GeoJSON Object";
                    g = this.coordsToLatLngs(b, 1, h);
                    g = NGR.polygon(g, a.mainStyle);
                    "labelStyle" in a && (a.labelStyle.boundPolygon = g, this._featureLabels[d.properties.id] = NGR.canvaslabel(g.getInnerPoint(),
                        a.labelStyle));
                    return g;
                case "Icon":
                    return h = h(b), a.mainStyle.icon = NGR.icon({
                        iconUrl: a.mainStyle.url,
                        iconSize: a.mainStyle.size
                    }), delete a.mainStyle.url, delete a.mainStyle.size, NGR.canvasmarker(h, a.mainStyle);
                default:
                    throw "Not a supported or invalid GeoJSON object.";
            }
        },
        coordsToLatLng: function(d) {
            return NGR.CRS.EPSG3857.unproject(NGR.point(d))
        },
        coordsToLatLngs: function(d, g, h) {
            var k, b, l, a;
            a = [];
            b = 0;
            for (l = d.length; b < l; b++) k = d[b], g ? a.push(this.coordsToLatLngs(k, g - 1, h)) : a.push((h || this.coordsToLatLng)(k));
            return a
        }
    });
    NGR.featureLayer = function(d, g) {
        return new NGR.FeatureLayer(d, g)
    }
}).call(this);
(function() {
    NGR.LocationProvider = NGR.Class.extend({
        includes: [NGR.Mixin.Events],
        statics: {
            MAC: 1,
            PLANAR_GRAPH: 3
        },
        options: {
            server: "http://192.168.3.190/comet/pos",
            timeout: 3E4
        },
        initialize: function(d) {
            NGR.Util.setOptions(this, d);
            this.planar = {};
            this.macPool = {};
            this.runningPlanarReq = this.runningMacReq = !1;
            return this.cooldownTime = 1E3
        },
        watch: function(d, g) {
            switch (d) {
                case NGR.LocationProvider.MAC:
                    this.macPool[g] = {
                        scheduleId: null,
                        feature: {}
                    };
                    this.runMacReq = !0;
                    break;
                case NGR.LocationProvider.PLANAR_GRAPH:
                    this.planar.id =
                        g;
                    this.planar.features = {};
                    this.runPlanarReq = !0;
                    break;
                default:
                    console.error("Not a valid location type.")
            }
            return this._loop()
        },
        unwatch: function(d, g) {
            switch (d) {
                case NGR.LocationProvider.MAC:
                    g in this.macPool && (clearTimeout(this.macPool[g].scheduleId), delete this.macPool[g]);
                    if (0 === Object.keys(this.macPool).length) return this.runMacReq = !1;
                    break;
                case NGR.LocationProvider.PLANAR_GRAPH:
                    if (g === this.planar.id) return clearTimeout(this.planar.scheduleId), delete this.planar.id, delete this.planar.features, this.runPlanarReq = !1;
                    break;
                default:
                    return console.error("Not a valid location type.")
            }
        },
        start: function() {
            0 !== this.macPool.length && (this.runMacReq = !0);
            this.planar.id && (this.runPlanarReq = !0);
            return this._loop()
        },
        terminate: function() {
            return this.runPlanarReq = this.runMacReq = !1
        },
        _loop: function() {
            var d, g;
            !this.runningMacReq && this.runMacReq && (this.runningMacReq = !0, d = function(g) {
                return function() {
                    return g._createMacRequest().then(function() {
                        1E3 !== g.cooldownTime && (g.cooldownTime = 1E3);
                        if (g.runMacReq) return d()
                    }).fail(function() {
                        return setTimeout(function() {
                                if (g.runMacReq) return d()
                            },
                            g.cooldownTime *= 2)
                    })
                }
            }(this), d());
            if (!this.runningPlanarReq && this.runPlanarReq) return this.runningPlanarReq = !0, g = function(d) {
                return function() {
                    return d._createPlanarRequest().then(function() {
                        1E3 !== d.cooldownTime && (d.cooldownTime = 1E3);
                        if (d.runPlanarReq) return g()
                    }).fail(function() {
                        return setTimeout(function() {
                            if (d.runPlanarReq) return g()
                        }, d.cooldownTime *= 2)
                    })
                }
            }(this), g()
        },
        _createMacRequest: function() {
            return NGR.IO.fetch({
                url: this.options.server,
                data: {
                    macs: Object.keys(this.macPool).join(",")
                },
                onsuccess: JSON.parse
            }).then(function(d) {
                return function(g) {
                    var h,
                        k, b, l;
                    h = function(a) {
                        var b, e, f;
                        if ("MAC" === a.properties.id_type) switch (b = NGR.CRS.EPSG3857.unproject(a.geometry.coordinates), a.geometry.coordinates[0] = b.lat, a.geometry.coordinates[1] = b.lng, e = a.properties.id_data, d._mergePointFeature(d.macPool[e].feature, a), b = function() {
                            d.macPool[e].feature.properties.status = "OUT";
                            d.macPool[e].scheduleId = null;
                            return d.fire("out", d.macPool[e].feature)
                        }, a.properties.status) {
                            case "ENTER":
                                return d.macPool[e].scheduleId ? clearTimeout(d.macPool[e].scheduleId) : f = !0, d.macPool[e].scheduleId =
                                    setTimeout(b, a.properties.expires_in || d.options.timeout), d.fire(f ? "enter" : "move", d.macPool[e].feature);
                            case "MOVE":
                                return d.macPool[e].scheduleId ? clearTimeout(d.macPool[e].scheduleId) : f = !0, d.macPool[e].scheduleId = setTimeout(b, a.properties.expires_in || d.options.timeout), d.fire(f ? "enter" : "move", d.macPool[e].feature);
                            case "OUT":
                                return "To be continue...";
                            case "HEART_BEAT":
                                return d.macPool[e].scheduleId ? clearTimeout(d.macPool[e].scheduleId) : (d.macPool[e].feature.properties.status = "ENTER", d.fire("enter",
                                    d.macPool[e].feature)), d.macPool[e].scheduleId = setTimeout(b, a.properties.expires_in || d.options.timeout);
                            default:
                                return console.error("Unknown location status.")
                        }
                    };
                    if ("Feature" === g.type) h(g);
                    else if ("FeatureCollection" === g.type)
                        for (l = g.features, k = 0, b = l.length; k < b; k++) g = l[k], h(g)
                }
            }(this))
        },
        _createPlanarRequest: function() {
            return NGR.IO.fetch({
                url: this.options.server,
                data: {
                    planar_graph_id: this.planar.id
                },
                onsuccess: JSON.parse
            }).then(function(d) {
                return function(g) {
                    var h, k, b, l;
                    h = function(a) {
                        var b, e, f;
                        if ("MAC" ===
                            a.properties.id_type) switch (b = NGR.CRS.EPSG3857.unproject(a.geometry.coordinates), a.geometry.coordinates[0] = b.lat, a.geometry.coordinates[1] = b.lng, e = a.properties.id_data, d.planar.features[e] || (d.planar.features[e] = {}, f = !0), d._mergePointFeature(d.planar.features[e], a), b = function() {
                            a.properties.status = "OUT";
                            if ("features" in d.planar)
                                if (e in d.planar.features) delete d.planar.features[e];
                                else debugger;
                            return d.fire("out", a)
                        }, a.properties.status) {
                            case "ENTER":
                                return d.planar.features[e].scheduleId && clearTimeout(d.planar.features[e].scheduleId),
                                    d.planar.features[e].scheduleId = setTimeout(b, a.properties.expires_in || d.options.timeout), d.fire(f ? "enter" : "move", d.planar.features[e]);
                            case "MOVE":
                                return d.planar.features[e].scheduleId && clearTimeout(d.planar.features[e].scheduleId), d.planar.features[e].scheduleId = setTimeout(b, a.properties.expires_in || d.options.timeout), d.fire(f ? "enter" : "move", d.planar.features[e]);
                            case "OUT":
                                return "To be continue...";
                            case "HEART_BEAT":
                                return d.planar.features[e].scheduleId ? clearTimeout(d.planar.features[e].scheduleId) :
                                    (d.planar.features[e].properties.status = "ENTER", d.fire("enter", d.planar.features[e])), d.planar.features[e].scheduleId = setTimeout(b, a.properties.expires_in || d.options.timeout);
                            default:
                                return console.error("Unknown location status.")
                        }
                    };
                    if ("Feature" === g.type) h(g);
                    else if ("FeatureCollection" === g.type)
                        for (l = g.features, k = 0, b = l.length; k < b; k++) g = l[k], h(g)
                }
            }(this))
        },
        _mergePointFeature: function(d, g) {
            var h, k;
            d.type = g.type;
            d.properties || (d.properties = {});
            for (h in d.properties) d.properties[h] = g.properties[h];
            for (h in g.properties) d.properties[h] = g.properties[h];
            d.geometry || (d.geometry = {});
            d.geometry.type = g.geometry.type;
            (k = d.geometry).coordinates || (k.coordinates = []);
            d.geometry.coordinates[0] = g.geometry.coordinates[0];
            return d.geometry.coordinates[1] = g.geometry.coordinates[1]
        }
    })
}).call(this);